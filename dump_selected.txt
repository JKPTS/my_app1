

===== FILE: main\app_main.c =====
SIZE: 1020 bytes | LASTWRITE: 2025-12-31T01:54:54.4401158+07:00
----- BEGIN CONTENT -----
#include "esp_log.h"
#include "nvs_flash.h"

#include "portal_wifi.h"
#include "config_store.h"
#include "footswitch.h"
#include "usb_midi_host.h"

static const char *TAG = "APP";

void app_main(void)
{
    // 1) NVS init (เก็บ config ถาวร)
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        nvs_flash_erase();
        nvs_flash_init();
    }

    // 2) โหลด/ตั้งค่า default config
    config_store_init();

    // 3) เริ่ม USB-MIDI Host (ให้ทำงานตลอด ไม่ต้องรีเซ็ตเมื่อถอดเสียบใหม่)
    usb_midi_host_init();

    // 4) เริ่ม Captive Portal (SoftAP + DNS hijack + HTTP server)
    portal_wifi_start();

    // 5) เริ่ม Footswitch engine (อ่านปุ่มจริง + bank/page + ส่ง MIDI ตาม config)
    footswitch_start();

    ESP_LOGI(TAG, "System ready");
}


----- END CONTENT -----

===== FILE: main\CMakeLists.txt =====
SIZE: 331 bytes | LASTWRITE: 2025-12-31T01:57:21.8973019+07:00
----- BEGIN CONTENT -----
idf_component_register(
  SRCS
    "app_main.c"
    "portal_wifi.c"
    "dns_hijack.c"
    "config_store.c"
    "footswitch.c"
    "midi_actions.c"
    "usb_midi_host.c"
  INCLUDE_DIRS "."
  REQUIRES
    nvs_flash
    esp_wifi
    esp_event
    esp_netif
    esp_http_server
    spiffs
    driver
    lwip
    json
    usb
)



----- END CONTENT -----

===== FILE: main\CMakeLists.txt.bak =====
SIZE: 330 bytes | LASTWRITE: 2025-12-31T01:54:54.3835375+07:00
----- BEGIN CONTENT -----
idf_component_register(
  SRCS
    "app_main.c"
    "portal_wifi.c"
    "dns_hijack.c"
    "config_store.c"
    "footswitch.c"
    "midi_actions.c"
    "usb_midi_host.c"
  INCLUDE_DIRS "."
  REQUIRES
    nvs_flash
    esp_wifi
    esp_event
    esp_netif
    esp_http_server
    spiffs
    driver
    lwip
    cjson
    usb
)


----- END CONTENT -----

===== FILE: main\config_store.c =====
SIZE: 7731 bytes | LASTWRITE: 2025-12-31T02:43:14.7185587+07:00
----- BEGIN CONTENT -----
#include <string.h>

#include "esp_log.h"
#include "nvs.h"
#include "cJSON.h"

#include "config_store.h"

static const char *TAG = "CFG";
static foot_config_t s_cfg;

static void set_default_action(action_t *a)
{
    a->type = ACT_NONE; a->ch = 1; a->a = 0; a->b = 0; a->c = 0;
}

static void set_defaults(void)
{
    memset(&s_cfg, 0, sizeof(s_cfg));
    for (int b = 0; b < NUM_BANKS; b++) {
        for (int p = 0; p < NUM_PAGES; p++) {
            for (int k = 0; k < NUM_BTNS; k++) {
                btn_map_t *m = &s_cfg.map[b][p][k];
                m->press_mode = BTN_SHORT_ONLY;
                m->cc_behavior = CC_NORMAL;
                for (int i = 0; i < MAX_ACTIONS; i++) {
                    set_default_action(&m->short_actions[i]);
                    set_default_action(&m->long_actions[i]);
                }
            }
        }
    }
}

const foot_config_t *config_store_get(void) { return &s_cfg; }

static esp_err_t nvs_load_json(char *out, size_t outlen)
{
    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READONLY, &h);
    if (e != ESP_OK) return e;

    size_t len = outlen;
    e = nvs_get_str(h, "config", out, &len);
    nvs_close(h);
    return e;
}

static esp_err_t nvs_save_json(const char *json)
{
    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READWRITE, &h);
    if (e != ESP_OK) return e;

    e = nvs_set_str(h, "config", json);
    if (e == ESP_OK) e = nvs_commit(h);
    nvs_close(h);
    return e;
}

static bool parse_action(cJSON *o, action_t *a)
{
    if (!cJSON_IsObject(o)) return false;

    const cJSON *type = cJSON_GetObjectItem(o, "type");
    const cJSON *ch   = cJSON_GetObjectItem(o, "ch");
    const cJSON *aa   = cJSON_GetObjectItem(o, "a");
    const cJSON *bb   = cJSON_GetObjectItem(o, "b");
    const cJSON *cc   = cJSON_GetObjectItem(o, "c");

    if (!cJSON_IsString(type) || !cJSON_IsNumber(ch) || !cJSON_IsNumber(aa) || !cJSON_IsNumber(bb) || !cJSON_IsNumber(cc)) return false;

    a->ch = (uint8_t)ch->valueint;
    a->a  = (uint8_t)aa->valueint;
    a->b  = (uint8_t)bb->valueint;
    a->c  = (uint8_t)cc->valueint;

    if      (strcmp(type->valuestring, "cc") == 0)      a->type = ACT_CC;
    else if (strcmp(type->valuestring, "pc") == 0)      a->type = ACT_PC;
    else if (strcmp(type->valuestring, "note") == 0)    a->type = ACT_NOTE;
    else if (strcmp(type->valuestring, "delay") == 0)   a->type = ACT_DELAY;
    else if (strcmp(type->valuestring, "bank_pc") == 0) a->type = ACT_BANK_PC;
    else a->type = ACT_NONE;

    return true;
}

static void action_to_json(cJSON *arr, const action_t *a)
{
    if (a->type == ACT_NONE) return;

    cJSON *o = cJSON_CreateObject();
    const char *t = "none";
    if (a->type == ACT_CC) t = "cc";
    else if (a->type == ACT_PC) t = "pc";
    else if (a->type == ACT_NOTE) t = "note";
    else if (a->type == ACT_DELAY) t = "delay";
    else if (a->type == ACT_BANK_PC) t = "bank_pc";

    cJSON_AddStringToObject(o, "type", t);
    cJSON_AddNumberToObject(o, "ch", a->ch);
    cJSON_AddNumberToObject(o, "a", a->a);
    cJSON_AddNumberToObject(o, "b", a->b);
    cJSON_AddNumberToObject(o, "c", a->c);
    cJSON_AddItemToArray(arr, o);
}

void config_store_init(void)
{
    set_defaults();
static char buf[8192];
    memset(buf, 0, sizeof(buf));
    if (nvs_load_json(buf, sizeof(buf)) != ESP_OK) {
        ESP_LOGW(TAG, "No saved config, using defaults");
        return;
    }
    (void)config_store_set_json(buf);
}

esp_err_t config_store_set_json(const char *json)
{
    cJSON *root = cJSON_Parse(json);
    if (!root) return ESP_FAIL;

    cJSON *banks = cJSON_GetObjectItem(root, "banks");
    if (!cJSON_IsArray(banks) || cJSON_GetArraySize(banks) != NUM_BANKS) {
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    foot_config_t tmp;
    memset(&tmp, 0, sizeof(tmp));

    for (int b = 0; b < NUM_BANKS; b++) {
        cJSON *bank = cJSON_GetArrayItem(banks, b);
        cJSON *pages = cJSON_GetObjectItem(bank, "pages");
        if (!cJSON_IsArray(pages) || cJSON_GetArraySize(pages) != NUM_PAGES) { cJSON_Delete(root); return ESP_FAIL; }

        for (int p = 0; p < NUM_PAGES; p++) {
            cJSON *page = cJSON_GetArrayItem(pages, p);
            cJSON *buttons = cJSON_GetObjectItem(page, "buttons");
            if (!cJSON_IsArray(buttons) || cJSON_GetArraySize(buttons) != NUM_BTNS) { cJSON_Delete(root); return ESP_FAIL; }

            for (int k = 0; k < NUM_BTNS; k++) {
                cJSON *btn = cJSON_GetArrayItem(buttons, k);
                btn_map_t *m = &tmp.map[b][p][k];

                cJSON *pm = cJSON_GetObjectItem(btn, "pressMode");
                cJSON *cb = cJSON_GetObjectItem(btn, "ccBehavior");
                if (!cJSON_IsNumber(pm) || !cJSON_IsNumber(cb)) { cJSON_Delete(root); return ESP_FAIL; }
                m->press_mode = (btn_press_mode_t)pm->valueint;
                m->cc_behavior = (cc_behavior_t)cb->valueint;

                for (int i = 0; i < MAX_ACTIONS; i++) { set_default_action(&m->short_actions[i]); set_default_action(&m->long_actions[i]); }

                cJSON *sa = cJSON_GetObjectItem(btn, "short");
                cJSON *la = cJSON_GetObjectItem(btn, "long");
                if (!cJSON_IsArray(sa) || !cJSON_IsArray(la)) { cJSON_Delete(root); return ESP_FAIL; }

                int ns = cJSON_GetArraySize(sa);
                if (ns > MAX_ACTIONS) ns = MAX_ACTIONS;
                for (int i = 0; i < ns; i++) {
                    if (!parse_action(cJSON_GetArrayItem(sa, i), &m->short_actions[i])) { cJSON_Delete(root); return ESP_FAIL; }
                }

                int nl = cJSON_GetArraySize(la);
                if (nl > MAX_ACTIONS) nl = MAX_ACTIONS;
                for (int i = 0; i < nl; i++) {
                    if (!parse_action(cJSON_GetArrayItem(la, i), &m->long_actions[i])) { cJSON_Delete(root); return ESP_FAIL; }
                }
            }
        }
    }

    cJSON_Delete(root);
    s_cfg = tmp;
    return nvs_save_json(json);
}

esp_err_t config_store_get_json(char *out, int out_len)
{
    cJSON *root = cJSON_CreateObject();
    cJSON *banks = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "banks", banks);

    for (int b = 0; b < NUM_BANKS; b++) {
        cJSON *bank = cJSON_CreateObject();
        cJSON *pages = cJSON_CreateArray();
        cJSON_AddItemToObject(bank, "pages", pages);
        cJSON_AddItemToArray(banks, bank);

        for (int p = 0; p < NUM_PAGES; p++) {
            cJSON *page = cJSON_CreateObject();
            cJSON *buttons = cJSON_CreateArray();
            cJSON_AddItemToObject(page, "buttons", buttons);
            cJSON_AddItemToArray(pages, page);

            for (int k = 0; k < NUM_BTNS; k++) {
                const btn_map_t *m = &s_cfg.map[b][p][k];
                cJSON *btn = cJSON_CreateObject();
                cJSON_AddNumberToObject(btn, "pressMode", (int)m->press_mode);
                cJSON_AddNumberToObject(btn, "ccBehavior", (int)m->cc_behavior);

                cJSON *sa = cJSON_CreateArray();
                cJSON *la = cJSON_CreateArray();
                cJSON_AddItemToObject(btn, "short", sa);
                cJSON_AddItemToObject(btn, "long", la);

                for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(sa, &m->short_actions[i]);
                for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(la, &m->long_actions[i]);

                cJSON_AddItemToArray(buttons, btn);
            }
        }
    }

    char *s = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);
    if (!s) return ESP_FAIL;

    int need = (int)strlen(s);
    if (need >= out_len) { free(s); return ESP_FAIL; }

    strcpy(out, s);
    free(s);
    return ESP_OK;
}



----- END CONTENT -----

===== FILE: main\config_store.c.bak_20251231_024314 =====
SIZE: 7699 bytes | LASTWRITE: 2025-12-31T01:54:55.3095313+07:00
----- BEGIN CONTENT -----
#include <string.h>

#include "esp_log.h"
#include "nvs.h"
#include "cJSON.h"

#include "config_store.h"

static const char *TAG = "CFG";
static foot_config_t s_cfg;

static void set_default_action(action_t *a)
{
    a->type = ACT_NONE; a->ch = 1; a->a = 0; a->b = 0; a->c = 0;
}

static void set_defaults(void)
{
    memset(&s_cfg, 0, sizeof(s_cfg));
    for (int b = 0; b < NUM_BANKS; b++) {
        for (int p = 0; p < NUM_PAGES; p++) {
            for (int k = 0; k < NUM_BTNS; k++) {
                btn_map_t *m = &s_cfg.map[b][p][k];
                m->press_mode = BTN_SHORT_ONLY;
                m->cc_behavior = CC_NORMAL;
                for (int i = 0; i < MAX_ACTIONS; i++) {
                    set_default_action(&m->short_actions[i]);
                    set_default_action(&m->long_actions[i]);
                }
            }
        }
    }
}

const foot_config_t *config_store_get(void) { return &s_cfg; }

static esp_err_t nvs_load_json(char *out, size_t outlen)
{
    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READONLY, &h);
    if (e != ESP_OK) return e;

    size_t len = outlen;
    e = nvs_get_str(h, "config", out, &len);
    nvs_close(h);
    return e;
}

static esp_err_t nvs_save_json(const char *json)
{
    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READWRITE, &h);
    if (e != ESP_OK) return e;

    e = nvs_set_str(h, "config", json);
    if (e == ESP_OK) e = nvs_commit(h);
    nvs_close(h);
    return e;
}

static bool parse_action(cJSON *o, action_t *a)
{
    if (!cJSON_IsObject(o)) return false;

    const cJSON *type = cJSON_GetObjectItem(o, "type");
    const cJSON *ch   = cJSON_GetObjectItem(o, "ch");
    const cJSON *aa   = cJSON_GetObjectItem(o, "a");
    const cJSON *bb   = cJSON_GetObjectItem(o, "b");
    const cJSON *cc   = cJSON_GetObjectItem(o, "c");

    if (!cJSON_IsString(type) || !cJSON_IsNumber(ch) || !cJSON_IsNumber(aa) || !cJSON_IsNumber(bb) || !cJSON_IsNumber(cc)) return false;

    a->ch = (uint8_t)ch->valueint;
    a->a  = (uint8_t)aa->valueint;
    a->b  = (uint8_t)bb->valueint;
    a->c  = (uint8_t)cc->valueint;

    if      (strcmp(type->valuestring, "cc") == 0)      a->type = ACT_CC;
    else if (strcmp(type->valuestring, "pc") == 0)      a->type = ACT_PC;
    else if (strcmp(type->valuestring, "note") == 0)    a->type = ACT_NOTE;
    else if (strcmp(type->valuestring, "delay") == 0)   a->type = ACT_DELAY;
    else if (strcmp(type->valuestring, "bank_pc") == 0) a->type = ACT_BANK_PC;
    else a->type = ACT_NONE;

    return true;
}

static void action_to_json(cJSON *arr, const action_t *a)
{
    if (a->type == ACT_NONE) return;

    cJSON *o = cJSON_CreateObject();
    const char *t = "none";
    if (a->type == ACT_CC) t = "cc";
    else if (a->type == ACT_PC) t = "pc";
    else if (a->type == ACT_NOTE) t = "note";
    else if (a->type == ACT_DELAY) t = "delay";
    else if (a->type == ACT_BANK_PC) t = "bank_pc";

    cJSON_AddStringToObject(o, "type", t);
    cJSON_AddNumberToObject(o, "ch", a->ch);
    cJSON_AddNumberToObject(o, "a", a->a);
    cJSON_AddNumberToObject(o, "b", a->b);
    cJSON_AddNumberToObject(o, "c", a->c);
    cJSON_AddItemToArray(arr, o);
}

void config_store_init(void)
{
    set_defaults();

    char buf[8192] = {0};
    if (nvs_load_json(buf, sizeof(buf)) != ESP_OK) {
        ESP_LOGW(TAG, "No saved config, using defaults");
        return;
    }
    (void)config_store_set_json(buf);
}

esp_err_t config_store_set_json(const char *json)
{
    cJSON *root = cJSON_Parse(json);
    if (!root) return ESP_FAIL;

    cJSON *banks = cJSON_GetObjectItem(root, "banks");
    if (!cJSON_IsArray(banks) || cJSON_GetArraySize(banks) != NUM_BANKS) {
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    foot_config_t tmp;
    memset(&tmp, 0, sizeof(tmp));

    for (int b = 0; b < NUM_BANKS; b++) {
        cJSON *bank = cJSON_GetArrayItem(banks, b);
        cJSON *pages = cJSON_GetObjectItem(bank, "pages");
        if (!cJSON_IsArray(pages) || cJSON_GetArraySize(pages) != NUM_PAGES) { cJSON_Delete(root); return ESP_FAIL; }

        for (int p = 0; p < NUM_PAGES; p++) {
            cJSON *page = cJSON_GetArrayItem(pages, p);
            cJSON *buttons = cJSON_GetObjectItem(page, "buttons");
            if (!cJSON_IsArray(buttons) || cJSON_GetArraySize(buttons) != NUM_BTNS) { cJSON_Delete(root); return ESP_FAIL; }

            for (int k = 0; k < NUM_BTNS; k++) {
                cJSON *btn = cJSON_GetArrayItem(buttons, k);
                btn_map_t *m = &tmp.map[b][p][k];

                cJSON *pm = cJSON_GetObjectItem(btn, "pressMode");
                cJSON *cb = cJSON_GetObjectItem(btn, "ccBehavior");
                if (!cJSON_IsNumber(pm) || !cJSON_IsNumber(cb)) { cJSON_Delete(root); return ESP_FAIL; }
                m->press_mode = (btn_press_mode_t)pm->valueint;
                m->cc_behavior = (cc_behavior_t)cb->valueint;

                for (int i = 0; i < MAX_ACTIONS; i++) { set_default_action(&m->short_actions[i]); set_default_action(&m->long_actions[i]); }

                cJSON *sa = cJSON_GetObjectItem(btn, "short");
                cJSON *la = cJSON_GetObjectItem(btn, "long");
                if (!cJSON_IsArray(sa) || !cJSON_IsArray(la)) { cJSON_Delete(root); return ESP_FAIL; }

                int ns = cJSON_GetArraySize(sa);
                if (ns > MAX_ACTIONS) ns = MAX_ACTIONS;
                for (int i = 0; i < ns; i++) {
                    if (!parse_action(cJSON_GetArrayItem(sa, i), &m->short_actions[i])) { cJSON_Delete(root); return ESP_FAIL; }
                }

                int nl = cJSON_GetArraySize(la);
                if (nl > MAX_ACTIONS) nl = MAX_ACTIONS;
                for (int i = 0; i < nl; i++) {
                    if (!parse_action(cJSON_GetArrayItem(la, i), &m->long_actions[i])) { cJSON_Delete(root); return ESP_FAIL; }
                }
            }
        }
    }

    cJSON_Delete(root);
    s_cfg = tmp;
    return nvs_save_json(json);
}

esp_err_t config_store_get_json(char *out, int out_len)
{
    cJSON *root = cJSON_CreateObject();
    cJSON *banks = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "banks", banks);

    for (int b = 0; b < NUM_BANKS; b++) {
        cJSON *bank = cJSON_CreateObject();
        cJSON *pages = cJSON_CreateArray();
        cJSON_AddItemToObject(bank, "pages", pages);
        cJSON_AddItemToArray(banks, bank);

        for (int p = 0; p < NUM_PAGES; p++) {
            cJSON *page = cJSON_CreateObject();
            cJSON *buttons = cJSON_CreateArray();
            cJSON_AddItemToObject(page, "buttons", buttons);
            cJSON_AddItemToArray(pages, page);

            for (int k = 0; k < NUM_BTNS; k++) {
                const btn_map_t *m = &s_cfg.map[b][p][k];
                cJSON *btn = cJSON_CreateObject();
                cJSON_AddNumberToObject(btn, "pressMode", (int)m->press_mode);
                cJSON_AddNumberToObject(btn, "ccBehavior", (int)m->cc_behavior);

                cJSON *sa = cJSON_CreateArray();
                cJSON *la = cJSON_CreateArray();
                cJSON_AddItemToObject(btn, "short", sa);
                cJSON_AddItemToObject(btn, "long", la);

                for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(sa, &m->short_actions[i]);
                for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(la, &m->long_actions[i]);

                cJSON_AddItemToArray(buttons, btn);
            }
        }
    }

    char *s = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);
    if (!s) return ESP_FAIL;

    int need = (int)strlen(s);
    if (need >= out_len) { free(s); return ESP_FAIL; }

    strcpy(out, s);
    free(s);
    return ESP_OK;
}


----- END CONTENT -----

===== FILE: main\config_store.h =====
SIZE: 1264 bytes | LASTWRITE: 2025-12-31T01:54:54.9823348+07:00
----- BEGIN CONTENT -----
#pragma once
#include "esp_err.h"
#include <stdint.h>

#define NUM_BANKS 20
#define NUM_PAGES 4
#define NUM_BTNS  8
#define MAX_ACTIONS 8

typedef enum {
    ACT_NONE = 0,
    ACT_CC,
    ACT_PC,
    ACT_NOTE,
    ACT_DELAY,
    ACT_BANK_PC,   // CC0+CC32+PC
} action_type_t;

typedef enum {
    BTN_SHORT_ONLY = 0,
    BTN_SHORT_LONG = 1,
} btn_press_mode_t;

typedef enum {
    CC_NORMAL = 0,
    CC_TOGGLE = 1,
    CC_MOMENTARY = 2,
} cc_behavior_t;

// action fields (compact):
// - CC:    ch, a=cc,  b=val, c=momentary_dur*10ms (optional)
// - PC:    ch, a=pc
// - NOTE:  ch, a=note, b=vel, c=dur*10ms
// - DELAY: ch ignored, a=ms_hi, b=ms_lo
// - BANK_PC: ch, a=pc, b=lsb, c=msb
typedef struct {
    action_type_t type;
    uint8_t ch;      // 1..16
    uint8_t a;
    uint8_t b;
    uint8_t c;
} action_t;

typedef struct {
    btn_press_mode_t press_mode;
    cc_behavior_t cc_behavior;
    action_t short_actions[MAX_ACTIONS];
    action_t long_actions[MAX_ACTIONS];
} btn_map_t;

typedef struct {
    btn_map_t map[NUM_BANKS][NUM_PAGES][NUM_BTNS];
} foot_config_t;

void config_store_init(void);
esp_err_t config_store_get_json(char *out, int out_len);
esp_err_t config_store_set_json(const char *json);

const foot_config_t *config_store_get(void);


----- END CONTENT -----

===== FILE: main\dns_hijack.c =====
SIZE: 1648 bytes | LASTWRITE: 2025-12-31T01:54:54.9069058+07:00
----- BEGIN CONTENT -----
#include <string.h>
#include <arpa/inet.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "lwip/sockets.h"
#include "esp_log.h"

static const char *TAG = "DNS";

static void dns_task(void *arg)
{
    (void)arg;

    int s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) {
        vTaskDelete(NULL);
        return;
    }

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(53);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(s, (struct sockaddr*)&addr, sizeof(addr));

    uint8_t buf[512];

    while (1) {
        struct sockaddr_in from = {0};
        socklen_t flen = sizeof(from);
        int n = recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&from, &flen);
        if (n < 12) continue;

        // Minimal DNS response:
        uint8_t out[512];
        memcpy(out, buf, n);

        // Header: set QR=1 response, RCODE=0, ANCOUNT=1
        out[2] = 0x81;
        out[3] = 0x80;
        out[6] = 0x00; out[7] = 0x01;

        // Answer:
        // NAME pointer 0xC00C, TYPE=A, CLASS=IN, TTL=60, RDLEN=4, RDATA=192.168.4.1
        int p = n;
        out[p++] = 0xC0; out[p++] = 0x0C;
        out[p++] = 0x00; out[p++] = 0x01;
        out[p++] = 0x00; out[p++] = 0x01;
        out[p++] = 0x00; out[p++] = 0x00; out[p++] = 0x00; out[p++] = 0x3C;
        out[p++] = 0x00; out[p++] = 0x04;
        out[p++] = 192; out[p++] = 168; out[p++] = 4; out[p++] = 1;

        sendto(s, out, p, 0, (struct sockaddr*)&from, flen);
    }
}

void dns_hijack_start(void)
{
    xTaskCreate(dns_task, "dns_hijack", 4096, NULL, 5, NULL);
    ESP_LOGI(TAG, "DNS hijack started");
}


----- END CONTENT -----

===== FILE: main\dns_hijack.h =====
SIZE: 46 bytes | LASTWRITE: 2025-12-31T01:54:54.8329025+07:00
----- BEGIN CONTENT -----
#pragma once
void dns_hijack_start(void);


----- END CONTENT -----

===== FILE: main\footswitch.c =====
SIZE: 3473 bytes | LASTWRITE: 2025-12-31T01:54:55.4868170+07:00
----- BEGIN CONTENT -----
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "driver/gpio.h"

#include "footswitch.h"
#include "config_store.h"
#include "midi_actions.h"

static const gpio_num_t sw_pins[8] = {
    (gpio_num_t)4, (gpio_num_t)5, (gpio_num_t)6, (gpio_num_t)7,
    (gpio_num_t)15,(gpio_num_t)16,(gpio_num_t)17,(gpio_num_t)18
};

static footswitch_state_t s_state = {0, 0};

static inline int pressed(int idx) { return gpio_get_level(sw_pins[idx]) == 0; } // pull-up: pressed=0

footswitch_state_t footswitch_get_state(void) { return s_state; }

void footswitch_set_state(int bank, int page)
{
    if (bank < 0) bank = 0;
    if (bank > 19) bank = 19;
    if (page < 0) page = 0;
    if (page > 3) page = 3;
    s_state.bank = (uint8_t)bank;
    s_state.page = (uint8_t)page;
}

// combo:
// 5&6 -> bank--
// 7&8 -> bank++
// 6&7 -> page++
static void apply_combo_logic(void)
{
    int b5 = pressed(4);
    int b6 = pressed(5);
    int b7 = pressed(6);
    int b8 = pressed(7);

    static int lock = 0;

    // ปล่อยหมด -> ปลด lock
    if (!b5 && !b6 && !b7 && !b8) {
        lock = 0;
        return;
    }
    if (lock) return;

    if (b5 && b6) {
        if (s_state.bank > 0) s_state.bank--;
        lock = 1;
        return;
    }
    if (b7 && b8) {
        if (s_state.bank < 19) s_state.bank++;
        lock = 1;
        return;
    }
    if (b6 && b7) {
        s_state.page = (s_state.page + 1) % 4;
        lock = 1;
        return;
    }
}

static void run_button_actions(int btn_index_0_7, int is_long)
{
    const foot_config_t *cfg = config_store_get();
    const btn_map_t *m = &cfg->map[s_state.bank][s_state.page][btn_index_0_7];

    const action_t *list = is_long ? m->long_actions : m->short_actions;

    // ถ้า MIDI ไม่พร้อม -> midi_actions_run จะ drop ทั้ง macro เอง (ไม่ buffer)
    midi_actions_run(list, MAX_ACTIONS, m->cc_behavior);
}

static void foot_task(void *arg)
{
    (void)arg;

    gpio_config_t io = {
        .pin_bit_mask = 0,
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = 1,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE,
    };
    for (int i = 0; i < 8; i++) io.pin_bit_mask |= (1ULL << sw_pins[i]);
    gpio_config(&io);

    uint8_t last[8];
    for (int i = 0; i < 8; i++) last[i] = 1;

    const int LONG_MS = 600;
    int hold_ms[8] = {0};

    while (1) {
        apply_combo_logic();

        for (int i = 0; i < 8; i++) {
            int now = gpio_get_level(sw_pins[i]); // 0 pressed, 1 released

            if (now == 0) hold_ms[i] += 10;

            // press edge
            if (last[i] == 1 && now == 0) {
                hold_ms[i] = 0;
            }

            // release edge -> short/long
            if (last[i] == 0 && now == 1) {
                int is_long = (hold_ms[i] >= LONG_MS) ? 1 : 0;

                const foot_config_t *cfg = config_store_get();
                const btn_map_t *m = &cfg->map[s_state.bank][s_state.page][i];

                if (m->press_mode == BTN_SHORT_ONLY && is_long) {
                    // drop long when short-only
                } else {
                    run_button_actions(i, is_long);
                }

                hold_ms[i] = 0;
            }

            last[i] = (uint8_t)now;
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void footswitch_start(void)
{
    xTaskCreatePinnedToCore(foot_task, "footswitch", 4096, NULL, 6, NULL, 1);
}


----- END CONTENT -----

===== FILE: main\footswitch.h =====
SIZE: 255 bytes | LASTWRITE: 2025-12-31T01:54:55.3454490+07:00
----- BEGIN CONTENT -----
#pragma once
#include <stdint.h>

typedef struct {
    uint8_t bank; // 0..19
    uint8_t page; // 0..3
} footswitch_state_t;

void footswitch_start(void);

footswitch_state_t footswitch_get_state(void);
void footswitch_set_state(int bank, int page);


----- END CONTENT -----

===== FILE: main\midi_actions.c =====
SIZE: 2696 bytes | LASTWRITE: 2025-12-31T01:54:56.1560936+07:00
----- BEGIN CONTENT -----
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "midi_actions.h"
#include "usb_midi_host.h"

// toggle state per (ch,cc)
static uint8_t s_toggle[16][128];

static uint8_t clamp7(int v) { if (v < 0) return 0; if (v > 127) return 127; return (uint8_t)v; }
static uint8_t clampCh(int v) { if (v < 1) return 1; if (v > 16) return 16; return (uint8_t)v; }

void midi_actions_run(const action_t *actions, int n, cc_behavior_t cc_behavior)
{
    // ไม่พร้อมส่ง -> drop ทั้ง macro (ไม่ buffer / ไม่ส่งย้อนหลัง)
    if (!usb_midi_ready_fast()) return;

    for (int i = 0; i < n; i++) {
        const action_t *a = &actions[i];
        if (a->type == ACT_NONE) continue;

        uint8_t ch = clampCh(a->ch);

        if (a->type == ACT_DELAY) {
            int ms = ((int)a->a << 8) | (int)a->b;
            if (ms < 0) ms = 0;
            vTaskDelay(pdMS_TO_TICKS(ms));
            continue;
        }

        if (a->type == ACT_CC) {
            uint8_t cc = clamp7(a->a);
            uint8_t val = clamp7(a->b);

            if (cc_behavior == CC_NORMAL) {
                (void)usb_midi_send_cc(ch, cc, val);
            } else if (cc_behavior == CC_TOGGLE) {
                uint8_t *st = &s_toggle[ch - 1][cc];
                *st = !(*st);
                (void)usb_midi_send_cc(ch, cc, *st ? 127 : 0);
            } else if (cc_behavior == CC_MOMENTARY) {
                int dur = (a->c == 0) ? 50 : (int)a->c * 10;
                (void)usb_midi_send_cc(ch, cc, 127);
                vTaskDelay(pdMS_TO_TICKS(dur));
                (void)usb_midi_send_cc(ch, cc, 0);
            }
            continue;
        }

        if (a->type == ACT_PC) {
            uint8_t pc = clamp7(a->a);
            (void)usb_midi_send_pc(ch, pc);
            continue;
        }

        if (a->type == ACT_BANK_PC) {
            uint8_t pc  = clamp7(a->a);
            uint8_t lsb = clamp7(a->b);
            uint8_t msb = clamp7(a->c);

            // bank select: CC0=MSB, CC32=LSB, then PC
            (void)usb_midi_send_cc(ch, 0, msb);
            vTaskDelay(pdMS_TO_TICKS(2));
            (void)usb_midi_send_cc(ch, 32, lsb);
            vTaskDelay(pdMS_TO_TICKS(2));
            (void)usb_midi_send_pc(ch, pc);
            continue;
        }

        if (a->type == ACT_NOTE) {
            uint8_t note = clamp7(a->a);
            uint8_t vel  = clamp7(a->b);
            int dur = (a->c == 0) ? 50 : (int)a->c * 10;

            (void)usb_midi_send_note_on(ch, note, vel);
            vTaskDelay(pdMS_TO_TICKS(dur));
            (void)usb_midi_send_note_off(ch, note, 0);
            continue;
        }
    }
}


----- END CONTENT -----

===== FILE: main\midi_actions.h =====
SIZE: 126 bytes | LASTWRITE: 2025-12-31T01:54:56.0454453+07:00
----- BEGIN CONTENT -----
#pragma once
#include "config_store.h"

void midi_actions_run(const action_t *actions, int n, cc_behavior_t cc_behavior);


----- END CONTENT -----

===== FILE: main\my_app.c =====
SIZE: 14708 bytes | LASTWRITE: 2025-12-31T01:13:45.0907442+07:00
----- BEGIN CONTENT -----
#include <stdio.h>
#include <string.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"

#include "esp_log.h"
#include "esp_err.h"

#include "driver/gpio.h"

#include "usb/usb_host.h"
#include "usb/usb_types_ch9.h"

static const char *TAG = "USB_MIDI_HOST";

// ส่งซ้ำทุก cable เผื่ออุปกรณ์รับไม่ใช่ cable 0 (ตั้ง 0 ก่อน ถ้าไม่ติดค่อยลอง 1)
#define SEND_ALL_CABLES   0

// -------------------- GPIO buttons (แก้ pin ตามบอร์ดคุณได้) --------------------
static const gpio_num_t sw_pins[8] = {
    (gpio_num_t)4, (gpio_num_t)5, (gpio_num_t)6, (gpio_num_t)7,
    (gpio_num_t)15,(gpio_num_t)16,(gpio_num_t)17,(gpio_num_t)18
};

// -------------------- CC request queue --------------------
typedef struct {
    uint8_t ch;   // 1..16
    uint8_t cc;   // 0..127
    uint8_t val;  // 0..127
} midi_cc_req_t;

static QueueHandle_t s_cc_queue;

// -------------------- USB host state --------------------
typedef struct {
    usb_host_client_handle_t client_hdl;
    usb_device_handle_t dev_hdl;

    bool have_device;
    bool claimed;
    uint8_t dev_addr;

    uint8_t midi_intf_num;
    uint8_t midi_ep_out;

    usb_transfer_t *xfer;
    SemaphoreHandle_t tx_done_sem;
} usb_midi_host_t;

static usb_midi_host_t s_usb;

// event flags from callback -> handled in client task (หลีกเลี่ยงทำงานหนักใน callback)
static volatile bool s_evt_new_dev = false;
static volatile bool s_evt_dev_gone = false;
static volatile uint8_t s_evt_new_addr = 0;

// Minimal header for walking descriptors
typedef struct __attribute__((packed)) {
    uint8_t bLength;
    uint8_t bDescriptorType;
} usb_desc_header_t;

// -------------------- USB Host daemon task --------------------
static void usb_host_daemon_task(void *arg)
{
    (void)arg;
    while (1) {
        uint32_t event_flags = 0;
        esp_err_t err = usb_host_lib_handle_events(portMAX_DELAY, &event_flags);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "usb_host_lib_handle_events err=%s", esp_err_to_name(err));
        }
    }
}

// -------------------- Find MIDI streaming interface + OUT endpoint --------------------
// Prefer BULK OUT, but accept INTERRUPT OUT if device uses it.
static bool find_midi_out_ep(const usb_config_desc_t *cfg, uint8_t *out_intf, uint8_t *out_ep)
{
    const uint8_t *p = (const uint8_t *)cfg;
    const uint8_t *end = p + cfg->wTotalLength;

    const usb_intf_desc_t *cur_intf = NULL;

    uint8_t found_intf = 0;
    uint8_t found_ep   = 0;
    bool found_bulk = false;

    while (p + sizeof(usb_desc_header_t) <= end) {
        const usb_desc_header_t *hdr = (const usb_desc_header_t *)p;
        if (hdr->bLength == 0) break;
        if (p + hdr->bLength > end) break;

        if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_INTERFACE) {
            cur_intf = (const usb_intf_desc_t *)p;

            // MIDI Streaming = Audio class(0x01), subclass(0x03)
            if (cur_intf->bInterfaceClass == 0x01 && cur_intf->bInterfaceSubClass == 0x03) {
                // keep candidate
            } else {
                cur_intf = NULL;
            }
        } else if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_ENDPOINT && cur_intf) {
            const usb_ep_desc_t *ep = (const usb_ep_desc_t *)p;

            uint8_t xfer_type = (ep->bmAttributes & 0x03);
            bool is_bulk      = (xfer_type == 0x02);
            bool is_interrupt = (xfer_type == 0x03);
            bool is_out       = ((ep->bEndpointAddress & 0x80) == 0x00);

            if (is_out && (is_bulk || is_interrupt)) {
                if (is_bulk) {
                    *out_intf = cur_intf->bInterfaceNumber;
                    *out_ep   = ep->bEndpointAddress;
                    return true;
                }
                if (!found_bulk) {
                    found_bulk = false;
                    found_intf = cur_intf->bInterfaceNumber;
                    found_ep   = ep->bEndpointAddress;
                }
            }
        }

        p += hdr->bLength;
    }

    if (found_ep) {
        *out_intf = found_intf;
        *out_ep   = found_ep;
        return true;
    }
    return false;
}

// -------------------- USB client event callback --------------------
static void client_event_cb(const usb_host_client_event_msg_t *event_msg, void *arg)
{
    (void)arg;
    if (event_msg->event == USB_HOST_CLIENT_EVENT_NEW_DEV) {
        s_evt_new_addr = event_msg->new_dev.address;
        s_evt_new_dev = true;
    } else if (event_msg->event == USB_HOST_CLIENT_EVENT_DEV_GONE) {
        s_evt_dev_gone = true;
    }
}

// -------------------- Transfer callback --------------------
static void transfer_cb(usb_transfer_t *transfer)
{
    if (transfer->status == USB_TRANSFER_STATUS_COMPLETED) {
        ESP_LOGI(TAG, "TX done (%d bytes)", (int)transfer->actual_num_bytes);
    } else {
        ESP_LOGW(TAG, "TX status=%d", (int)transfer->status);
    }
    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

// -------------------- Build USB-MIDI event packet for CC --------------------
// USB-MIDI event packet (4 bytes):
// [0]= (Cable<<4) | CIN ; [1]=status ; [2]=data1 ; [3]=data2
static void build_midi_cc_packet(uint8_t *pkt4, uint8_t cable, uint8_t ch_1_16, uint8_t cc, uint8_t val)
{
    if (ch_1_16 < 1) ch_1_16 = 1;
    if (ch_1_16 > 16) ch_1_16 = 16;

    uint8_t cin = 0x0B; // Control Change (3 bytes)

    // ✅ FIXED: byte0 = (Cable<<4) | CIN
    pkt4[0] = (uint8_t)(((cable & 0x0F) << 4) | (cin & 0x0F));
    pkt4[1] = (uint8_t)(0xB0 | ((ch_1_16 - 1) & 0x0F));
    pkt4[2] = (uint8_t)(cc & 0x7F);
    pkt4[3] = (uint8_t)(val & 0x7F);
}

// -------------------- Fast readiness check (ไม่ไปยุ่ง USB stack) --------------------
static inline bool midi_ready_fast(void)
{
    return (s_usb.have_device &&
            s_usb.dev_hdl != NULL &&
            s_usb.claimed &&
            s_usb.xfer != NULL &&
            s_usb.midi_ep_out != 0);
}

// -------------------- Cleanly close device --------------------
static void midi_close_device(void)
{
    // ✅ ไม่ส่งย้อนหลัง: ล้างคิวทันทีเมื่อหลุด
    if (s_cc_queue) {
        xQueueReset(s_cc_queue);
    }

    if (!s_usb.dev_hdl) {
        s_usb.have_device = false;
        s_usb.claimed = false;
        s_usb.midi_ep_out = 0;
        s_usb.midi_intf_num = 0;
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
        return;
    }

    // พยายามหยุด/flush endpoint (กันค้าง)
    if (s_usb.midi_ep_out) {
        (void)usb_host_endpoint_halt(s_usb.dev_hdl, s_usb.midi_ep_out);
        (void)usb_host_endpoint_flush(s_usb.dev_hdl, s_usb.midi_ep_out);
    }

    // release interface ก่อน close
    if (s_usb.claimed) {
        (void)usb_host_interface_release(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num);
        s_usb.claimed = false;
    }

    // close device
    (void)usb_host_device_close(s_usb.client_hdl, s_usb.dev_hdl);
    s_usb.dev_hdl = NULL;

    // clear state
    s_usb.have_device = false;
    s_usb.midi_ep_out = 0;
    s_usb.midi_intf_num = 0;

    if (s_usb.xfer) {
        s_usb.xfer->device_handle = NULL;
        s_usb.xfer->bEndpointAddress = 0;
    }

    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

// -------------------- Ensure device opened + interface claimed + endpoint found --------------------
static esp_err_t ensure_midi_ready(void)
{
    if (!s_usb.have_device) return ESP_ERR_INVALID_STATE;

    if (s_usb.dev_hdl == NULL) {
        esp_err_t e = usb_host_device_open(s_usb.client_hdl, s_usb.dev_addr, &s_usb.dev_hdl);
        if (e != ESP_OK) return e;

        const usb_config_desc_t *cfg_desc = NULL;
        e = usb_host_get_active_config_descriptor(s_usb.dev_hdl, &cfg_desc);
        if (e != ESP_OK) {
            midi_close_device();
            return e;
        }

        uint8_t intf = 0, ep_out = 0;
        if (!find_midi_out_ep(cfg_desc, &intf, &ep_out)) {
            ESP_LOGE(TAG, "No MIDI OUT endpoint found");
            midi_close_device();
            return ESP_FAIL;
        }

        s_usb.midi_intf_num = intf;
        s_usb.midi_ep_out   = ep_out;

        ESP_LOGI(TAG, "MIDI found: intf=%u ep_out=0x%02X", s_usb.midi_intf_num, s_usb.midi_ep_out);

        e = usb_host_interface_claim(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num, 0);
        if (e != ESP_OK) {
            midi_close_device();
            return e;
        }
        s_usb.claimed = true;

        if (s_usb.xfer == NULL) {
            e = usb_host_transfer_alloc(64, 0, &s_usb.xfer);
            if (e != ESP_OK) {
                midi_close_device();
                return e;
            }
            s_usb.xfer->callback = transfer_cb;
            s_usb.xfer->context = NULL;
        }
        s_usb.xfer->device_handle = s_usb.dev_hdl;
        s_usb.xfer->bEndpointAddress = s_usb.midi_ep_out;
    }

    return ESP_OK;
}

// -------------------- Send CC (host -> device) --------------------
static esp_err_t usb_midi_send_cc(uint8_t ch, uint8_t cc, uint8_t val)
{
    esp_err_t ready = ensure_midi_ready();
    if (ready != ESP_OK) return ready;

    if (s_usb.tx_done_sem) xSemaphoreTake(s_usb.tx_done_sem, pdMS_TO_TICKS(1000));

#if SEND_ALL_CABLES
    for (uint8_t cable = 0; cable < 16; cable++) {
        uint8_t pkt[4];
        build_midi_cc_packet(pkt, cable, ch, cc, val);

        memcpy(s_usb.xfer->data_buffer, pkt, 4);
        s_usb.xfer->num_bytes = 4;

        esp_err_t err = usb_host_transfer_submit(s_usb.xfer);
        if (err != ESP_OK) {
            if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
            return err;
        }

        if (s_usb.tx_done_sem) xSemaphoreTake(s_usb.tx_done_sem, pdMS_TO_TICKS(1000));
        vTaskDelay(pdMS_TO_TICKS(2));
    }
    return ESP_OK;
#else
    uint8_t pkt[4];
    build_midi_cc_packet(pkt, 0, ch, cc, val);

    memcpy(s_usb.xfer->data_buffer, pkt, 4);
    s_usb.xfer->num_bytes = 4;

    esp_err_t err = usb_host_transfer_submit(s_usb.xfer);
    if (err != ESP_OK) {
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
    }
    return err;
#endif
}

// -------------------- Button task: press -> increment val; send only if ready --------------------
static void button_task(void *arg)
{
    (void)arg;

    uint8_t last[8];
    for (int i = 0; i < 8; i++) last[i] = 1;

    // GP-50: CC0 = 0..99 (Patch 00..99)
    uint8_t val = 0;

    while (1) {
        for (int i = 0; i < 8; i++) {
            int now = gpio_get_level(sw_pins[i]); // INPUT_PULLUP: pressed=0
            if (last[i] == 1 && now == 0) {
                // wait release (simple debounce)
                while (gpio_get_level(sw_pins[i]) == 0) vTaskDelay(pdMS_TO_TICKS(10));

                // ✅ กดแล้ว "นับค่า" ไปเรื่อย ๆ เสมอ
                midi_cc_req_t req = { .ch = 1, .cc = 0, .val = val };

                // ✅ เงื่อนไขสำคัญ:
                // ถ้า USB-MIDI ไม่ ready -> ไม่เก็บ ไม่ enqueue ไม่ส่งย้อนหลัง
                if (midi_ready_fast()) {
                    // ถ้าคิวเต็มทิ้งอันเก่าสุด
                    if (uxQueueSpacesAvailable(s_cc_queue) == 0) {
                        midi_cc_req_t dummy;
                        (void)xQueueReceive(s_cc_queue, &dummy, 0);
                    }
                    (void)xQueueSend(s_cc_queue, &req, 0);
                }

                val++;
                if (val > 99) val = 0;
            }
            last[i] = (uint8_t)now;
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// -------------------- USB client task --------------------
static void usb_client_task(void *arg)
{
    (void)arg;

    usb_host_client_config_t client_cfg = {
        .is_synchronous = false,
        .max_num_event_msg = 5,
        .async = {
            .client_event_callback = client_event_cb,
            .callback_arg = NULL,
        },
    };

    ESP_ERROR_CHECK(usb_host_client_register(&client_cfg, &s_usb.client_hdl));
    ESP_LOGI(TAG, "USB client registered");

    while (1) {
        usb_host_client_handle_events(s_usb.client_hdl, pdMS_TO_TICKS(20));

        // handle DEV_GONE safely here
        if (s_evt_dev_gone) {
            s_evt_dev_gone = false;
            ESP_LOGW(TAG, "DEV_GONE");
            midi_close_device();
        }

        // handle NEW_DEV safely here
        if (s_evt_new_dev) {
            s_evt_new_dev = false;
            s_usb.dev_addr = s_evt_new_addr;
            s_usb.have_device = true;
            ESP_LOGI(TAG, "NEW_DEV addr=%u", s_usb.dev_addr);
        }

        // warm-up: ถ้ามีอุปกรณ์เสียบแล้วแต่ยังไม่ open/claim ให้เตรียมไว้
        if (s_usb.have_device && s_usb.dev_hdl == NULL) {
            (void)ensure_midi_ready();
        }

        // send queued requests (เฉพาะที่กดตอน ready)
        midi_cc_req_t req;
        if (xQueueReceive(s_cc_queue, &req, 0) == pdTRUE) {
            esp_err_t err = usb_midi_send_cc(req.ch, req.cc, req.val);
            // ถ้าส่งไม่ผ่านก็ทิ้งเลย (ไม่ส่งย้อนหลัง)
            (void)err;
        }

        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

void app_main(void)
{
    gpio_config_t io = {
        .pin_bit_mask = 0,
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = 1,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE,
    };
    for (int i = 0; i < 8; i++) {
        io.pin_bit_mask |= (1ULL << sw_pins[i]);
    }
    ESP_ERROR_CHECK(gpio_config(&io));

    s_cc_queue = xQueueCreate(64, sizeof(midi_cc_req_t));

    s_usb.tx_done_sem = xSemaphoreCreateBinary();
    xSemaphoreGive(s_usb.tx_done_sem);

    usb_host_config_t host_cfg = {
        .intr_flags = ESP_INTR_FLAG_LEVEL1,
    };
    ESP_ERROR_CHECK(usb_host_install(&host_cfg));
    ESP_LOGI(TAG, "USB Host installed");

    xTaskCreatePinnedToCore(usb_host_daemon_task, "usb_daemon", 4096, NULL, 20, NULL, 0);
    xTaskCreatePinnedToCore(usb_client_task, "usb_client", 8192, NULL, 15, NULL, 1);
    xTaskCreatePinnedToCore(button_task, "buttons", 4096, NULL, 5, NULL, 1);

    ESP_LOGI(TAG, "Ready. Press button to send CC0 val 0..99 (no buffering when disconnected)");
}


----- END CONTENT -----

===== FILE: main\portal_wifi.c =====
SIZE: 7673 bytes | LASTWRITE: 2025-12-31T02:43:14.7361194+07:00
----- BEGIN CONTENT -----
#include <string.h>
#include <stdio.h>

#include "esp_log.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_http_server.h"
#include "esp_spiffs.h"

#include "dns_hijack.h"
#include "config_store.h"
#include "footswitch.h"

static const char *TAG = "PORTAL";
static httpd_handle_t s_http = NULL;

static esp_err_t send_spiffs_file(httpd_req_t *req, const char *path, const char *ctype)
{
    FILE *f = fopen(path, "rb");
    if (!f) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "file not found");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, ctype);

    char buf[1024];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
        if (httpd_resp_send_chunk(req, buf, n) != ESP_OK) {
            fclose(f);
            httpd_resp_sendstr_chunk(req, NULL);
            return ESP_FAIL;
        }
    }

    fclose(f);
    httpd_resp_sendstr_chunk(req, NULL);
    return ESP_OK;
}

// -------- Static files --------
static esp_err_t h_root(httpd_req_t *req) { return send_spiffs_file(req, "/spiffs/index.html", "text/html"); }
static esp_err_t h_js(httpd_req_t *req)   { return send_spiffs_file(req, "/spiffs/app.js", "application/javascript"); }
static esp_err_t h_css(httpd_req_t *req)  { return send_spiffs_file(req, "/spiffs/style.css", "text/css"); }

// -------- Captive portal detection endpoints (redirect to /) --------
static esp_err_t h_redirect_to_root(httpd_req_t *req)
{
    httpd_resp_set_status(req, "302 Found");
    httpd_resp_set_hdr(req, "Location", "/");
    httpd_resp_send(req, NULL, 0);
    return ESP_OK;
}

// Android captive check: /generate_204
static esp_err_t h_generate_204(httpd_req_t *req) { return h_redirect_to_root(req); }
// iOS/macOS: /hotspot-detect.html
static esp_err_t h_hotspot(httpd_req_t *req)      { return h_redirect_to_root(req); }
// Windows NCSI: /ncsi.txt or /connecttest.txt
static esp_err_t h_ncsi(httpd_req_t *req)         { return h_redirect_to_root(req); }

// -------- API: GET/POST config --------
static esp_err_t h_get_config(httpd_req_t *req)
{
static char json[8192];
    memset(json, 0, sizeof(json));
    if (config_store_get_json(json, sizeof(json)) != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "config read failed");
        return ESP_FAIL;
    }
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json);
    return ESP_OK;
}

static esp_err_t h_post_config(httpd_req_t *req)
{
    int total = req->content_len;
    if (total <= 0 || total > 8192) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char *buf = (char *)calloc(1, total + 1);
    if (!buf) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            free(buf);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    esp_err_t e = config_store_set_json(buf);
    free(buf);

    if (e != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "config invalid");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

// -------- API: GET/POST state (bank/page live sync) --------
static esp_err_t h_get_state(httpd_req_t *req)
{
    footswitch_state_t st = footswitch_get_state();
    char out[128];
    snprintf(out, sizeof(out), "{\"bank\":%u,\"page\":%u}", (unsigned)st.bank, (unsigned)st.page);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    return ESP_OK;
}

static esp_err_t h_post_state(httpd_req_t *req)
{
    int total = req->content_len;
    if (total <= 0 || total > 128) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char buf[129];
    int r = httpd_req_recv(req, buf, total);
    if (r <= 0) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
        return ESP_FAIL;
    }
    buf[r] = 0;

    int bank = -1, page = -1;
    if (sscanf(buf, "{\"bank\":%d,\"page\":%d}", &bank, &page) != 2) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json");
        return ESP_FAIL;
    }

    footswitch_set_state(bank, page);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

static void start_http_server(void)
{
    httpd_config_t cfg = HTTPD_DEFAULT_CONFIG();
    cfg.max_uri_handlers = 32;

    ESP_ERROR_CHECK(httpd_start(&s_http, &cfg));

    httpd_uri_t u_root = { .uri="/", .method=HTTP_GET, .handler=h_root };
    httpd_uri_t u_js   = { .uri="/app.js", .method=HTTP_GET, .handler=h_js };
    httpd_uri_t u_css  = { .uri="/style.css", .method=HTTP_GET, .handler=h_css };

    httpd_uri_t u_204  = { .uri="/generate_204", .method=HTTP_GET, .handler=h_generate_204 };
    httpd_uri_t u_hot  = { .uri="/hotspot-detect.html", .method=HTTP_GET, .handler=h_hotspot };
    httpd_uri_t u_ncsi = { .uri="/ncsi.txt", .method=HTTP_GET, .handler=h_ncsi };
    httpd_uri_t u_ct   = { .uri="/connecttest.txt", .method=HTTP_GET, .handler=h_ncsi };

    httpd_uri_t u_gc   = { .uri="/api/config", .method=HTTP_GET, .handler=h_get_config };
    httpd_uri_t u_pc   = { .uri="/api/config", .method=HTTP_POST, .handler=h_post_config };

    httpd_uri_t u_gs   = { .uri="/api/state", .method=HTTP_GET, .handler=h_get_state };
    httpd_uri_t u_ps   = { .uri="/api/state", .method=HTTP_POST, .handler=h_post_state };

    httpd_register_uri_handler(s_http, &u_root);
    httpd_register_uri_handler(s_http, &u_js);
    httpd_register_uri_handler(s_http, &u_css);

    httpd_register_uri_handler(s_http, &u_204);
    httpd_register_uri_handler(s_http, &u_hot);
    httpd_register_uri_handler(s_http, &u_ncsi);
    httpd_register_uri_handler(s_http, &u_ct);

    httpd_register_uri_handler(s_http, &u_gc);
    httpd_register_uri_handler(s_http, &u_pc);

    httpd_register_uri_handler(s_http, &u_gs);
    httpd_register_uri_handler(s_http, &u_ps);

    ESP_LOGI(TAG, "HTTP server started");
}

static void mount_spiffs(void)
{
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = NULL,
        .max_files = 8,
        .format_if_mount_failed = true,
    };
    ESP_ERROR_CHECK(esp_vfs_spiffs_register(&conf));
    ESP_LOGI(TAG, "SPIFFS mounted");
}

void portal_wifi_start(void)
{
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    esp_netif_create_default_wifi_ap();

    wifi_init_config_t wicfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&wicfg));

    wifi_config_t ap = { 0 };
    strcpy((char*)ap.ap.ssid, "FOOTSWITCH-SETUP");
    strcpy((char*)ap.ap.password, "12345678"); // เปลี่ยนได้
    ap.ap.ssid_len = 0;
    ap.ap.max_connection = 2;
    ap.ap.authmode = WIFI_AUTH_WPA_WPA2_PSK;
    if (strlen((char*)ap.ap.password) == 0) ap.ap.authmode = WIFI_AUTH_OPEN;

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap));
    ESP_ERROR_CHECK(esp_wifi_start());

    mount_spiffs();

    // DNS hijack: พิมพ์โดเมนไหนก็พาเข้าหน้าเรา
    dns_hijack_start();

    start_http_server();

    ESP_LOGI(TAG, "Captive portal ready. Connect Wi-Fi 'FOOTSWITCH-SETUP' then open 192.168.4.1");
}



----- END CONTENT -----

===== FILE: main\portal_wifi.c.bak_20251231_024314 =====
SIZE: 7632 bytes | LASTWRITE: 2025-12-31T01:54:54.8016313+07:00
----- BEGIN CONTENT -----
#include <string.h>
#include <stdio.h>

#include "esp_log.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_http_server.h"
#include "esp_spiffs.h"

#include "dns_hijack.h"
#include "config_store.h"
#include "footswitch.h"

static const char *TAG = "PORTAL";
static httpd_handle_t s_http = NULL;

static esp_err_t send_spiffs_file(httpd_req_t *req, const char *path, const char *ctype)
{
    FILE *f = fopen(path, "rb");
    if (!f) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "file not found");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, ctype);

    char buf[1024];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
        if (httpd_resp_send_chunk(req, buf, n) != ESP_OK) {
            fclose(f);
            httpd_resp_sendstr_chunk(req, NULL);
            return ESP_FAIL;
        }
    }

    fclose(f);
    httpd_resp_sendstr_chunk(req, NULL);
    return ESP_OK;
}

// -------- Static files --------
static esp_err_t h_root(httpd_req_t *req) { return send_spiffs_file(req, "/spiffs/index.html", "text/html"); }
static esp_err_t h_js(httpd_req_t *req)   { return send_spiffs_file(req, "/spiffs/app.js", "application/javascript"); }
static esp_err_t h_css(httpd_req_t *req)  { return send_spiffs_file(req, "/spiffs/style.css", "text/css"); }

// -------- Captive portal detection endpoints (redirect to /) --------
static esp_err_t h_redirect_to_root(httpd_req_t *req)
{
    httpd_resp_set_status(req, "302 Found");
    httpd_resp_set_hdr(req, "Location", "/");
    httpd_resp_send(req, NULL, 0);
    return ESP_OK;
}

// Android captive check: /generate_204
static esp_err_t h_generate_204(httpd_req_t *req) { return h_redirect_to_root(req); }
// iOS/macOS: /hotspot-detect.html
static esp_err_t h_hotspot(httpd_req_t *req)      { return h_redirect_to_root(req); }
// Windows NCSI: /ncsi.txt or /connecttest.txt
static esp_err_t h_ncsi(httpd_req_t *req)         { return h_redirect_to_root(req); }

// -------- API: GET/POST config --------
static esp_err_t h_get_config(httpd_req_t *req)
{
    char json[8192];
    if (config_store_get_json(json, sizeof(json)) != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "config read failed");
        return ESP_FAIL;
    }
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json);
    return ESP_OK;
}

static esp_err_t h_post_config(httpd_req_t *req)
{
    int total = req->content_len;
    if (total <= 0 || total > 8192) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char *buf = (char *)calloc(1, total + 1);
    if (!buf) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            free(buf);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    esp_err_t e = config_store_set_json(buf);
    free(buf);

    if (e != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "config invalid");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

// -------- API: GET/POST state (bank/page live sync) --------
static esp_err_t h_get_state(httpd_req_t *req)
{
    footswitch_state_t st = footswitch_get_state();
    char out[128];
    snprintf(out, sizeof(out), "{\"bank\":%u,\"page\":%u}", (unsigned)st.bank, (unsigned)st.page);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    return ESP_OK;
}

static esp_err_t h_post_state(httpd_req_t *req)
{
    int total = req->content_len;
    if (total <= 0 || total > 128) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char buf[129];
    int r = httpd_req_recv(req, buf, total);
    if (r <= 0) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
        return ESP_FAIL;
    }
    buf[r] = 0;

    int bank = -1, page = -1;
    if (sscanf(buf, "{\"bank\":%d,\"page\":%d}", &bank, &page) != 2) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json");
        return ESP_FAIL;
    }

    footswitch_set_state(bank, page);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

static void start_http_server(void)
{
    httpd_config_t cfg = HTTPD_DEFAULT_CONFIG();
    cfg.max_uri_handlers = 32;

    ESP_ERROR_CHECK(httpd_start(&s_http, &cfg));

    httpd_uri_t u_root = { .uri="/", .method=HTTP_GET, .handler=h_root };
    httpd_uri_t u_js   = { .uri="/app.js", .method=HTTP_GET, .handler=h_js };
    httpd_uri_t u_css  = { .uri="/style.css", .method=HTTP_GET, .handler=h_css };

    httpd_uri_t u_204  = { .uri="/generate_204", .method=HTTP_GET, .handler=h_generate_204 };
    httpd_uri_t u_hot  = { .uri="/hotspot-detect.html", .method=HTTP_GET, .handler=h_hotspot };
    httpd_uri_t u_ncsi = { .uri="/ncsi.txt", .method=HTTP_GET, .handler=h_ncsi };
    httpd_uri_t u_ct   = { .uri="/connecttest.txt", .method=HTTP_GET, .handler=h_ncsi };

    httpd_uri_t u_gc   = { .uri="/api/config", .method=HTTP_GET, .handler=h_get_config };
    httpd_uri_t u_pc   = { .uri="/api/config", .method=HTTP_POST, .handler=h_post_config };

    httpd_uri_t u_gs   = { .uri="/api/state", .method=HTTP_GET, .handler=h_get_state };
    httpd_uri_t u_ps   = { .uri="/api/state", .method=HTTP_POST, .handler=h_post_state };

    httpd_register_uri_handler(s_http, &u_root);
    httpd_register_uri_handler(s_http, &u_js);
    httpd_register_uri_handler(s_http, &u_css);

    httpd_register_uri_handler(s_http, &u_204);
    httpd_register_uri_handler(s_http, &u_hot);
    httpd_register_uri_handler(s_http, &u_ncsi);
    httpd_register_uri_handler(s_http, &u_ct);

    httpd_register_uri_handler(s_http, &u_gc);
    httpd_register_uri_handler(s_http, &u_pc);

    httpd_register_uri_handler(s_http, &u_gs);
    httpd_register_uri_handler(s_http, &u_ps);

    ESP_LOGI(TAG, "HTTP server started");
}

static void mount_spiffs(void)
{
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = NULL,
        .max_files = 8,
        .format_if_mount_failed = true,
    };
    ESP_ERROR_CHECK(esp_vfs_spiffs_register(&conf));
    ESP_LOGI(TAG, "SPIFFS mounted");
}

void portal_wifi_start(void)
{
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    esp_netif_create_default_wifi_ap();

    wifi_init_config_t wicfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&wicfg));

    wifi_config_t ap = { 0 };
    strcpy((char*)ap.ap.ssid, "FOOTSWITCH-SETUP");
    strcpy((char*)ap.ap.password, "12345678"); // เปลี่ยนได้
    ap.ap.ssid_len = 0;
    ap.ap.max_connection = 2;
    ap.ap.authmode = WIFI_AUTH_WPA_WPA2_PSK;
    if (strlen((char*)ap.ap.password) == 0) ap.ap.authmode = WIFI_AUTH_OPEN;

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap));
    ESP_ERROR_CHECK(esp_wifi_start());

    mount_spiffs();

    // DNS hijack: พิมพ์โดเมนไหนก็พาเข้าหน้าเรา
    dns_hijack_start();

    start_http_server();

    ESP_LOGI(TAG, "Captive portal ready. Connect Wi-Fi 'FOOTSWITCH-SETUP' then open 192.168.4.1");
}


----- END CONTENT -----

===== FILE: main\portal_wifi.h =====
SIZE: 47 bytes | LASTWRITE: 2025-12-31T01:54:54.4663402+07:00
----- BEGIN CONTENT -----
#pragma once
void portal_wifi_start(void);


----- END CONTENT -----

===== FILE: main\usb_midi_host.c =====
SIZE: 10904 bytes | LASTWRITE: 2025-12-31T01:54:56.0178180+07:00
----- BEGIN CONTENT -----
#include <string.h>
#include <stdbool.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"

#include "esp_log.h"
#include "esp_err.h"

#include "usb/usb_host.h"
#include "usb/usb_types_ch9.h"

#include "usb_midi_host.h"

static const char *TAG = "USB_MIDI";

#define SEND_ALL_CABLES 0

typedef struct {
    usb_host_client_handle_t client_hdl;
    usb_device_handle_t dev_hdl;

    bool have_device;
    bool claimed;
    uint8_t dev_addr;

    uint8_t midi_intf_num;
    uint8_t midi_ep_out;

    usb_transfer_t *xfer;
    SemaphoreHandle_t tx_done_sem;
} usb_midi_host_state_t;

static usb_midi_host_state_t s_usb;

// event flags from callback -> handled in client task
static volatile bool s_evt_new_dev = false;
static volatile bool s_evt_dev_gone = false;
static volatile uint8_t s_evt_new_addr = 0;

// Minimal header for walking descriptors
typedef struct __attribute__((packed)) {
    uint8_t bLength;
    uint8_t bDescriptorType;
} usb_desc_header_t;

// -------------------- Transfer callback --------------------
static void transfer_cb(usb_transfer_t *transfer)
{
    if (transfer->status == USB_TRANSFER_STATUS_COMPLETED) {
        // ok
    } else {
        ESP_LOGW(TAG, "TX status=%d", (int)transfer->status);
    }
    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

// -------------------- USB client event callback --------------------
static void client_event_cb(const usb_host_client_event_msg_t *event_msg, void *arg)
{
    (void)arg;
    if (event_msg->event == USB_HOST_CLIENT_EVENT_NEW_DEV) {
        s_evt_new_addr = event_msg->new_dev.address;
        s_evt_new_dev = true;
    } else if (event_msg->event == USB_HOST_CLIENT_EVENT_DEV_GONE) {
        s_evt_dev_gone = true;
    }
}

// -------------------- Find MIDI streaming interface + OUT endpoint --------------------
static bool find_midi_out_ep(const usb_config_desc_t *cfg, uint8_t *out_intf, uint8_t *out_ep)
{
    const uint8_t *p = (const uint8_t *)cfg;
    const uint8_t *end = p + cfg->wTotalLength;

    const usb_intf_desc_t *cur_intf = NULL;

    uint8_t found_intf = 0;
    uint8_t found_ep   = 0;
    bool found_bulk = false;

    while (p + sizeof(usb_desc_header_t) <= end) {
        const usb_desc_header_t *hdr = (const usb_desc_header_t *)p;
        if (hdr->bLength == 0) break;
        if (p + hdr->bLength > end) break;

        if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_INTERFACE) {
            cur_intf = (const usb_intf_desc_t *)p;

            // MIDI Streaming = Audio class(0x01), subclass(0x03)
            if (cur_intf->bInterfaceClass == 0x01 && cur_intf->bInterfaceSubClass == 0x03) {
                // keep
            } else {
                cur_intf = NULL;
            }
        } else if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_ENDPOINT && cur_intf) {
            const usb_ep_desc_t *ep = (const usb_ep_desc_t *)p;

            uint8_t xfer_type = (ep->bmAttributes & 0x03);
            bool is_bulk      = (xfer_type == 0x02);
            bool is_interrupt = (xfer_type == 0x03);
            bool is_out       = ((ep->bEndpointAddress & 0x80) == 0x00);

            if (is_out && (is_bulk || is_interrupt)) {
                if (is_bulk) {
                    *out_intf = cur_intf->bInterfaceNumber;
                    *out_ep   = ep->bEndpointAddress;
                    return true;
                }
                if (!found_bulk) {
                    found_bulk = false;
                    found_intf = cur_intf->bInterfaceNumber;
                    found_ep   = ep->bEndpointAddress;
                }
            }
        }
        p += hdr->bLength;
    }

    if (found_ep) {
        *out_intf = found_intf;
        *out_ep   = found_ep;
        return true;
    }
    return false;
}

static inline uint8_t clamp_ch(uint8_t ch_1_16)
{
    if (ch_1_16 < 1) return 1;
    if (ch_1_16 > 16) return 16;
    return ch_1_16;
}

// USB-MIDI event packet (4 bytes): [0]=(Cable<<4)|CIN [1]=status [2]=d1 [3]=d2
static inline void build_pkt_3b(uint8_t *pkt, uint8_t cable, uint8_t cin, uint8_t status, uint8_t d1, uint8_t d2)
{
    pkt[0] = (uint8_t)(((cable & 0x0F) << 4) | (cin & 0x0F));
    pkt[1] = status;
    pkt[2] = d1;
    pkt[3] = d2;
}
static inline void build_pkt_2b(uint8_t *pkt, uint8_t cable, uint8_t cin, uint8_t status, uint8_t d1)
{
    pkt[0] = (uint8_t)(((cable & 0x0F) << 4) | (cin & 0x0F));
    pkt[1] = status;
    pkt[2] = d1;
    pkt[3] = 0x00;
}

static void midi_close_device(void)
{
    if (!s_usb.dev_hdl) {
        s_usb.have_device = false;
        s_usb.claimed = false;
        s_usb.midi_ep_out = 0;
        s_usb.midi_intf_num = 0;
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
        return;
    }

    if (s_usb.midi_ep_out) {
        (void)usb_host_endpoint_halt(s_usb.dev_hdl, s_usb.midi_ep_out);
        (void)usb_host_endpoint_flush(s_usb.dev_hdl, s_usb.midi_ep_out);
    }

    if (s_usb.claimed) {
        (void)usb_host_interface_release(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num);
        s_usb.claimed = false;
    }

    (void)usb_host_device_close(s_usb.client_hdl, s_usb.dev_hdl);
    s_usb.dev_hdl = NULL;

    s_usb.have_device = false;
    s_usb.midi_ep_out = 0;
    s_usb.midi_intf_num = 0;

    if (s_usb.xfer) {
        s_usb.xfer->device_handle = NULL;
        s_usb.xfer->bEndpointAddress = 0;
    }

    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

static esp_err_t ensure_midi_ready(void)
{
    if (!s_usb.have_device) return ESP_ERR_INVALID_STATE;

    if (s_usb.dev_hdl == NULL) {
        esp_err_t e = usb_host_device_open(s_usb.client_hdl, s_usb.dev_addr, &s_usb.dev_hdl);
        if (e != ESP_OK) return e;

        const usb_config_desc_t *cfg_desc = NULL;
        e = usb_host_get_active_config_descriptor(s_usb.dev_hdl, &cfg_desc);
        if (e != ESP_OK) { midi_close_device(); return e; }

        uint8_t intf = 0, ep_out = 0;
        if (!find_midi_out_ep(cfg_desc, &intf, &ep_out)) {
            ESP_LOGE(TAG, "No MIDI OUT endpoint found");
            midi_close_device();
            return ESP_FAIL;
        }

        s_usb.midi_intf_num = intf;
        s_usb.midi_ep_out = ep_out;

        e = usb_host_interface_claim(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num, 0);
        if (e != ESP_OK) { midi_close_device(); return e; }
        s_usb.claimed = true;

        if (s_usb.xfer == NULL) {
            e = usb_host_transfer_alloc(64, 0, &s_usb.xfer);
            if (e != ESP_OK) { midi_close_device(); return e; }
            s_usb.xfer->callback = transfer_cb;
            s_usb.xfer->context = NULL;
        }

        s_usb.xfer->device_handle = s_usb.dev_hdl;
        s_usb.xfer->bEndpointAddress = s_usb.midi_ep_out;
    }

    return ESP_OK;
}

int usb_midi_ready_fast(void)
{
    return (s_usb.have_device &&
            s_usb.dev_hdl != NULL &&
            s_usb.claimed &&
            s_usb.xfer != NULL &&
            s_usb.midi_ep_out != 0);
}

static esp_err_t submit_pkt(const uint8_t pkt4[4])
{
    if (ensure_midi_ready() != ESP_OK) return ESP_ERR_INVALID_STATE;

    if (s_usb.tx_done_sem) xSemaphoreTake(s_usb.tx_done_sem, pdMS_TO_TICKS(1000));

    memcpy(s_usb.xfer->data_buffer, pkt4, 4);
    s_usb.xfer->num_bytes = 4;

    esp_err_t err = usb_host_transfer_submit(s_usb.xfer);
    if (err != ESP_OK) {
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
    }
    return err;
}

esp_err_t usb_midi_send_cc(uint8_t ch_1_16, uint8_t cc, uint8_t val)
{
    ch_1_16 = clamp_ch(ch_1_16);

#if SEND_ALL_CABLES
    esp_err_t last = ESP_OK;
    for (uint8_t cable = 0; cable < 16; cable++) {
        uint8_t pkt[4];
        build_pkt_3b(pkt, cable, 0x0B, (uint8_t)(0xB0 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(cc & 0x7F), (uint8_t)(val & 0x7F));
        last = submit_pkt(pkt);
        if (last != ESP_OK) break;
        vTaskDelay(pdMS_TO_TICKS(2));
    }
    return last;
#else
    uint8_t pkt[4];
    build_pkt_3b(pkt, 0, 0x0B, (uint8_t)(0xB0 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(cc & 0x7F), (uint8_t)(val & 0x7F));
    return submit_pkt(pkt);
#endif
}

esp_err_t usb_midi_send_pc(uint8_t ch_1_16, uint8_t pc)
{
    ch_1_16 = clamp_ch(ch_1_16);

    uint8_t pkt[4];
    // CIN 0x0C = Program Change (2 bytes)
    build_pkt_2b(pkt, 0, 0x0C, (uint8_t)(0xC0 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(pc & 0x7F));
    return submit_pkt(pkt);
}

esp_err_t usb_midi_send_note_on(uint8_t ch_1_16, uint8_t note, uint8_t vel)
{
    ch_1_16 = clamp_ch(ch_1_16);

    uint8_t pkt[4];
    // CIN 0x09 = Note On (3 bytes)
    build_pkt_3b(pkt, 0, 0x09, (uint8_t)(0x90 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(note & 0x7F), (uint8_t)(vel & 0x7F));
    return submit_pkt(pkt);
}

esp_err_t usb_midi_send_note_off(uint8_t ch_1_16, uint8_t note, uint8_t vel)
{
    ch_1_16 = clamp_ch(ch_1_16);

    uint8_t pkt[4];
    // CIN 0x08 = Note Off (3 bytes)
    build_pkt_3b(pkt, 0, 0x08, (uint8_t)(0x80 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(note & 0x7F), (uint8_t)(vel & 0x7F));
    return submit_pkt(pkt);
}

// -------------------- tasks --------------------
static void usb_host_daemon_task(void *arg)
{
    (void)arg;
    while (1) {
        uint32_t event_flags = 0;
        esp_err_t err = usb_host_lib_handle_events(portMAX_DELAY, &event_flags);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "usb_host_lib_handle_events err=%s", esp_err_to_name(err));
        }
    }
}

static void usb_client_task(void *arg)
{
    (void)arg;

    usb_host_client_config_t client_cfg = {
        .is_synchronous = false,
        .max_num_event_msg = 8,
        .async = {
            .client_event_callback = client_event_cb,
            .callback_arg = NULL,
        },
    };

    ESP_ERROR_CHECK(usb_host_client_register(&client_cfg, &s_usb.client_hdl));
    ESP_LOGI(TAG, "USB client registered");

    while (1) {
        usb_host_client_handle_events(s_usb.client_hdl, pdMS_TO_TICKS(20));

        if (s_evt_dev_gone) {
            s_evt_dev_gone = false;
            ESP_LOGW(TAG, "DEV_GONE");
            midi_close_device();
        }

        if (s_evt_new_dev) {
            s_evt_new_dev = false;
            s_usb.dev_addr = s_evt_new_addr;
            s_usb.have_device = true;
            ESP_LOGI(TAG, "NEW_DEV addr=%u", s_usb.dev_addr);
            (void)ensure_midi_ready();
        }

        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

void usb_midi_host_init(void)
{
    // binary semaphore for TX serialize
    s_usb.tx_done_sem = xSemaphoreCreateBinary();
    xSemaphoreGive(s_usb.tx_done_sem);

    usb_host_config_t host_cfg = {
        .intr_flags = ESP_INTR_FLAG_LEVEL1,
    };
    ESP_ERROR_CHECK(usb_host_install(&host_cfg));
    ESP_LOGI(TAG, "USB Host installed");

    xTaskCreatePinnedToCore(usb_host_daemon_task, "usb_daemon", 4096, NULL, 20, NULL, 0);
    xTaskCreatePinnedToCore(usb_client_task, "usb_client", 8192, NULL, 15, NULL, 1);
}


----- END CONTENT -----

===== FILE: main\usb_midi_host.h =====
SIZE: 431 bytes | LASTWRITE: 2025-12-31T01:54:55.5344179+07:00
----- BEGIN CONTENT -----
#pragma once
#include <stdint.h>
#include "esp_err.h"

void usb_midi_host_init(void);

// ready check
int usb_midi_ready_fast(void);

// sending
esp_err_t usb_midi_send_cc(uint8_t ch_1_16, uint8_t cc, uint8_t val);
esp_err_t usb_midi_send_pc(uint8_t ch_1_16, uint8_t pc);
esp_err_t usb_midi_send_note_on(uint8_t ch_1_16, uint8_t note, uint8_t vel);
esp_err_t usb_midi_send_note_off(uint8_t ch_1_16, uint8_t note, uint8_t vel);


----- END CONTENT -----

===== FILE: CMakeLists.txt =====
SIZE: 232 bytes | LASTWRITE: 2025-12-31T01:54:54.3009156+07:00
----- BEGIN CONTENT -----
cmake_minimum_required(VERSION 3.16)

include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(my_app)

# Build SPIFFS image from ./spiffs into partition "storage"
spiffs_create_partition_image(storage spiffs FLASH_IN_PROJECT)


----- END CONTENT -----

===== FILE: CMakeLists.txt.bak =====
SIZE: 116 bytes | LASTWRITE: 2025-12-30T21:04:30.0194691+07:00
----- BEGIN CONTENT -----
cmake_minimum_required(VERSION 3.16)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(my_usb_host_midi)


----- END CONTENT -----

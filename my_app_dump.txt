===== FILE: CMakeLists.txt =====
cmake_minimum_required(VERSION 3.16)

include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(my_app)

# Build SPIFFS image from ./spiffs into partition "storage"
spiffs_create_partition_image(storage spiffs FLASH_IN_PROJECT)

===== END FILE: CMakeLists.txt =====

===== FILE: partitions.csv =====
# Name,   Type, SubType, Offset,  Size,    Flags
nvs,      data, nvs,     0x9000,  256K,
phy_init, data, phy,     0x49000, 4K,
factory,  app,  factory, 0x50000, 2M,
storage,  data, spiffs,  0x250000,0xDB0000,

===== END FILE: partitions.csv =====

===== FILE: main\CMakeLists.txt =====
idf_component_register(
  SRCS
    "app_main.c"
    "portal_wifi.c"
    "dns_hijack.c"
    "config_store.c"
    "footswitch.c"
    "midi_actions.c"
    "usb_midi_host.c"
  INCLUDE_DIRS "."
  REQUIRES
    nvs_flash
    esp_wifi
    esp_event
    esp_netif
    esp_http_server
    spiffs
    driver
    lwip
    json
    usb
)

===== END FILE: main\CMakeLists.txt =====

===== FILE: main\app_main.c =====
#include "esp_log.h"

#include "esp_err.h"
#include "portal_wifi.h"
#include "config_store.h"
#include "footswitch.h"
#include "usb_midi_host.h"


#include "nvs_flash.h"

static const char *TAG = "APP";

void app_main(void)
{
    // 1) NVS init (เก็บ config ถาวร)
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        nvs_flash_erase();
        nvs_flash_init();
    }

    // 2) โหลด/ตั้งค่า default config
    config_store_init();

    // 3) เริ่ม USB-MIDI Host (ให้ทำงานตลอด ไม่ต้องรีเซ็ตเมื่อถอดเสียบใหม่)
    usb_midi_host_init();

    // 4) เริ่ม Captive Portal (SoftAP + DNS hijack + HTTP server)
    portal_wifi_start();

    // 5) เริ่ม Footswitch engine (อ่านปุ่มจริง + bank/page + ส่ง MIDI ตาม config)
    footswitch_start();

    ESP_LOGI(TAG, "System ready");
}

===== END FILE: main\app_main.c =====

===== FILE: main\config_store.c =====
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "esp_log.h"
#include "esp_err.h"
#include "nvs.h"
#include "nvs_flash.h"
#include "cJSON.h"

#include "config_store.h"

static const char *TAG = "CFG";

static foot_config_t s_cfg;

#define CFG_MAGIC 0x46435346u  // 'FSCF'
#define CFG_VER   2            // bump to v2

// ---- storage blobs ----
// v1 (เดิม): size เป็น uint16_t ทำให้ล้นเมื่อ struct ใหญ่
typedef struct __attribute__((packed)) {
    uint32_t magic;
    uint16_t ver;
    uint16_t size;      // BUG: overflow for big cfg
    foot_config_t cfg;
} cfg_blob_v1_t;

// v2 (ใหม่): size เป็น uint32_t
typedef struct __attribute__((packed)) {
    uint32_t magic;
    uint16_t ver;
    uint16_t reserved;
    uint32_t size;      // FIXED
    foot_config_t cfg;
} cfg_blob_v2_t;

static inline int clampi(int v, int lo, int hi)
{
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
}

static inline int wrapi(int v, int max)
{
    if (max <= 0) return 0;
    int r = v % max;
    if (r < 0) r += max;
    return r;
}

static void set_default_action(action_t *a)
{
    if (!a) return;
    a->type = ACT_NONE;
    a->ch   = 1;
    a->a    = 0;
    a->b    = 0;
    a->c    = 0;
}

static void safe_set_name(char dst[NAME_LEN], const char *src, const char *fallback)
{
    const char *s = (src && src[0]) ? src : fallback;
    if (!s) s = "";
    strncpy(dst, s, NAME_LEN - 1);
    dst[NAME_LEN - 1] = 0;
}

static void set_defaults(void)
{
    memset(&s_cfg, 0, sizeof(s_cfg));

    s_cfg.bank_count = MAX_BANKS;
    for (int b = 0; b < MAX_BANKS; b++) {
        s_cfg.page_count[b] = MAX_PAGES;

        char bn[NAME_LEN];
        snprintf(bn, sizeof(bn), "Bank %d", b + 1);
        safe_set_name(s_cfg.bank_name[b], bn, "Bank");

        for (int p = 0; p < MAX_PAGES; p++) {
            char pn[NAME_LEN];
            snprintf(pn, sizeof(pn), "Page %d", p + 1);
            safe_set_name(s_cfg.page_name[b][p], pn, "Page");

            for (int k = 0; k < NUM_BTNS; k++) {
                btn_map_t *m = &s_cfg.map[b][p][k];
                m->press_mode  = BTN_IMMEDIATE;
                m->cc_behavior = CC_NORMAL;
                for (int i = 0; i < MAX_ACTIONS; i++) {
                    set_default_action(&m->short_actions[i]);
                    set_default_action(&m->long_actions[i]);
                }
            }
        }
    }
}

// ---------- NVS blob ----------
static esp_err_t nvs_load_blob(foot_config_t *out)
{
    if (!out) return ESP_ERR_INVALID_ARG;

    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READONLY, &h);
    if (e != ESP_OK) return e;

    size_t len = 0;
    e = nvs_get_blob(h, "cfg_blob", NULL, &len);
    if (e != ESP_OK) { nvs_close(h); return e; }

    uint8_t *buf = (uint8_t *)malloc(len);
    if (!buf) { nvs_close(h); return ESP_ERR_NO_MEM; }

    e = nvs_get_blob(h, "cfg_blob", buf, &len);
    nvs_close(h);

    if (e != ESP_OK) { free(buf); return e; }

    // v2
    if (len == sizeof(cfg_blob_v2_t)) {
        const cfg_blob_v2_t *b = (const cfg_blob_v2_t *)buf;
        if (b->magic == CFG_MAGIC && b->ver == CFG_VER && b->size == sizeof(foot_config_t)) {
            memcpy(out, &b->cfg, sizeof(*out));
            free(buf);
            return ESP_OK;
        }
        free(buf);
        return ESP_FAIL;
    }

    // v1 (legacy): size field overflow, so don't trust b->size
    if (len == sizeof(cfg_blob_v1_t)) {
        const cfg_blob_v1_t *b1 = (const cfg_blob_v1_t *)buf;
        if (b1->magic == CFG_MAGIC && b1->ver == 1) {
            memcpy(out, &b1->cfg, sizeof(*out));
            free(buf);
            return ESP_OK;
        }
        free(buf);
        return ESP_FAIL;
    }

    free(buf);
    return ESP_FAIL;
}

static esp_err_t nvs_save_blob(const foot_config_t *in)
{
    if (!in) return ESP_ERR_INVALID_ARG;

    // ✅ FIX: ห้ามวาง cfg_blob_v2_t บน stack เพราะ foot_config_t ใหญ่มาก
    cfg_blob_v2_t *blob = (cfg_blob_v2_t *)malloc(sizeof(cfg_blob_v2_t));
    if (!blob) return ESP_ERR_NO_MEM;

    memset(blob, 0, sizeof(*blob));
    blob->magic = CFG_MAGIC;
    blob->ver   = CFG_VER;
    blob->size  = (uint32_t)sizeof(foot_config_t);
    memcpy(&blob->cfg, in, sizeof(*in));

    nvs_handle_t h;
    esp_err_t e = nvs_open("footsw", NVS_READWRITE, &h);
    if (e != ESP_OK) { free(blob); return e; }

    e = nvs_set_blob(h, "cfg_blob", blob, sizeof(*blob));
    if (e == ESP_OK) e = nvs_commit(h);
    nvs_close(h);

    free(blob);

    if (e != ESP_OK) {
        ESP_LOGE(TAG, "nvs_save_blob failed: %s", esp_err_to_name(e));
    }
    return e;
}

const foot_config_t *config_store_get(void)
{
    return &s_cfg;
}

void config_store_init(void)
{
    // ✅ กันเคสลืม init NVS ที่อื่น
    esp_err_t e = nvs_flash_init();
    if (e == ESP_ERR_NVS_NO_FREE_PAGES || e == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(TAG, "NVS needs erase (e=%s)", esp_err_to_name(e));
        ESP_ERROR_CHECK(nvs_flash_erase());
        e = nvs_flash_init();
    }
    ESP_ERROR_CHECK(e);

    set_defaults();

    e = nvs_load_blob(&s_cfg);
    if (e == ESP_OK) {
        ESP_LOGI(TAG, "Loaded config blob from NVS");
        // sanitize counts
        s_cfg.bank_count = (uint8_t)clampi((int)s_cfg.bank_count, 1, MAX_BANKS);
        for (int b = 0; b < MAX_BANKS; b++) {
            s_cfg.page_count[b] = (uint8_t)clampi((int)s_cfg.page_count[b], 1, MAX_PAGES);
            s_cfg.bank_name[b][NAME_LEN - 1] = 0;
            for (int p = 0; p < MAX_PAGES; p++) {
                s_cfg.page_name[b][p][NAME_LEN - 1] = 0;
            }
        }
    } else {
        ESP_LOGW(TAG, "No saved config blob, using defaults (e=%s)", esp_err_to_name(e));
        e = nvs_save_blob(&s_cfg);
        if (e != ESP_OK) {
            ESP_LOGE(TAG, "save default failed (NVS too small?): %s", esp_err_to_name(e));
        }
    }
}

// ---- layout helpers ----
int config_store_bank_count(void)
{
    return (int)clampi((int)s_cfg.bank_count, 1, MAX_BANKS);
}

int config_store_page_count(int bank)
{
    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    return (int)clampi((int)s_cfg.page_count[bank], 1, MAX_PAGES);
}

const char *config_store_bank_name(int bank)
{
    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    return s_cfg.bank_name[bank];
}

const char *config_store_page_name(int bank, int page)
{
    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    return s_cfg.page_name[bank][page];
}

esp_err_t config_store_get_layout_json(char *out, int out_len)
{
    if (!out || out_len <= 0) return ESP_ERR_INVALID_ARG;

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "maxBanks", MAX_BANKS);
    cJSON_AddNumberToObject(root, "maxPages", MAX_PAGES);

    int bc = config_store_bank_count();
    cJSON_AddNumberToObject(root, "bankCount", bc);

    cJSON *banks = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "banks", banks);

    for (int b = 0; b < bc; b++) {
        cJSON *bo = cJSON_CreateObject();
        cJSON_AddNumberToObject(bo, "index", b);
        cJSON_AddStringToObject(bo, "name", s_cfg.bank_name[b]);

        int pc = (int)clampi((int)s_cfg.page_count[b], 1, MAX_PAGES);
        cJSON_AddNumberToObject(bo, "pageCount", pc);

        cJSON *pages = cJSON_CreateArray();
        cJSON_AddItemToObject(bo, "pages", pages);
        for (int p = 0; p < pc; p++) {
            cJSON_AddItemToArray(pages, cJSON_CreateString(s_cfg.page_name[b][p]));
        }

        cJSON_AddItemToArray(banks, bo);
    }

    char *s = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);
    if (!s) return ESP_FAIL;

    int need = (int)strlen(s);
    if (need >= out_len) {
        free(s);
        return ESP_FAIL;
    }

    strcpy(out, s);
    free(s);
    return ESP_OK;
}

esp_err_t config_store_set_layout_json(const char *json)
{
    if (!json) return ESP_ERR_INVALID_ARG;

    cJSON *root = cJSON_Parse(json);
    if (!root) return ESP_FAIL;

    cJSON *jbc = cJSON_GetObjectItem(root, "bankCount");
    cJSON *jbanks = cJSON_GetObjectItem(root, "banks");
    if (!cJSON_IsNumber(jbc) || !cJSON_IsArray(jbanks)) {
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    int bc = clampi(jbc->valueint, 1, MAX_BANKS);

    // temp copies (avoid partial write)
    uint8_t new_bank_count = (uint8_t)bc;
    uint8_t new_page_count[MAX_BANKS];
    char new_bank_name[MAX_BANKS][NAME_LEN];
    char new_page_name[MAX_BANKS][MAX_PAGES][NAME_LEN];

    // start from current to keep old names if missing
    memcpy(new_page_count, s_cfg.page_count, sizeof(new_page_count));
    memcpy(new_bank_name, s_cfg.bank_name, sizeof(new_bank_name));
    memcpy(new_page_name, s_cfg.page_name, sizeof(new_page_name));

    for (int b = 0; b < bc; b++) {
        cJSON *bo = cJSON_GetArrayItem(jbanks, b);
        if (!cJSON_IsObject(bo)) { cJSON_Delete(root); return ESP_FAIL; }

        cJSON *bn = cJSON_GetObjectItem(bo, "name");
        cJSON *pc = cJSON_GetObjectItem(bo, "pageCount");
        cJSON *pages = cJSON_GetObjectItem(bo, "pages");

        if (cJSON_IsString(bn)) safe_set_name(new_bank_name[b], bn->valuestring, new_bank_name[b]);
        else safe_set_name(new_bank_name[b], NULL, new_bank_name[b]);

        int pcount = cJSON_IsNumber(pc) ? clampi(pc->valueint, 1, MAX_PAGES) : clampi((int)new_page_count[b], 1, MAX_PAGES);
        new_page_count[b] = (uint8_t)pcount;

        if (cJSON_IsArray(pages)) {
            int n = cJSON_GetArraySize(pages);
            if (n > pcount) n = pcount;
            for (int p = 0; p < n; p++) {
                cJSON *ps = cJSON_GetArrayItem(pages, p);
                if (cJSON_IsString(ps)) {
                    safe_set_name(new_page_name[b][p], ps->valuestring, new_page_name[b][p]);
                }
            }
        }

        // ensure null-termination
        new_bank_name[b][NAME_LEN - 1] = 0;
        for (int p = 0; p < MAX_PAGES; p++) new_page_name[b][p][NAME_LEN - 1] = 0;
    }

    cJSON_Delete(root);

    // apply
    s_cfg.bank_count = new_bank_count;
    memcpy(s_cfg.page_count, new_page_count, sizeof(new_page_count));
    memcpy(s_cfg.bank_name, new_bank_name, sizeof(new_bank_name));
    memcpy(s_cfg.page_name, new_page_name, sizeof(new_page_name));

    return nvs_save_blob(&s_cfg);
}

// ---------- JSON helpers (per-button) ----------
static bool parse_action(cJSON *o, action_t *a)
{
    if (!cJSON_IsObject(o) || !a) return false;

    const cJSON *type = cJSON_GetObjectItem(o, "type");
    const cJSON *ch   = cJSON_GetObjectItem(o, "ch");
    const cJSON *aa   = cJSON_GetObjectItem(o, "a");
    const cJSON *bb   = cJSON_GetObjectItem(o, "b");
    const cJSON *cc   = cJSON_GetObjectItem(o, "c");

    if (!cJSON_IsString(type) || !cJSON_IsNumber(ch) ||
        !cJSON_IsNumber(aa)   || !cJSON_IsNumber(bb) ||
        !cJSON_IsNumber(cc)) {
        return false;
    }

    a->ch = (uint8_t)ch->valueint;
    a->a  = (uint8_t)aa->valueint;
    a->b  = (uint8_t)bb->valueint;
    a->c  = (uint8_t)cc->valueint;

    if      (strcmp(type->valuestring, "cc") == 0)      a->type = ACT_CC;
    else if (strcmp(type->valuestring, "pc") == 0)      a->type = ACT_PC;
    else if (strcmp(type->valuestring, "note") == 0)    a->type = ACT_NOTE;
    else if (strcmp(type->valuestring, "delay") == 0)   a->type = ACT_DELAY;
    else if (strcmp(type->valuestring, "bank_pc") == 0) a->type = ACT_BANK_PC;
    else                                                a->type = ACT_NONE;

    return true;
}

static void action_to_json(cJSON *arr, const action_t *a)
{
    if (!arr || !a) return;
    if (a->type == ACT_NONE) return;

    const char *t = "none";
    if      (a->type == ACT_CC)      t = "cc";
    else if (a->type == ACT_PC)      t = "pc";
    else if (a->type == ACT_NOTE)    t = "note";
    else if (a->type == ACT_DELAY)   t = "delay";
    else if (a->type == ACT_BANK_PC) t = "bank_pc";

    cJSON *o = cJSON_CreateObject();
    cJSON_AddStringToObject(o, "type", t);
    cJSON_AddNumberToObject(o, "ch", a->ch);
    cJSON_AddNumberToObject(o, "a",  a->a);
    cJSON_AddNumberToObject(o, "b",  a->b);
    cJSON_AddNumberToObject(o, "c",  a->c);
    cJSON_AddItemToArray(arr, o);
}

esp_err_t config_store_get_btn_json(int bank, int page, int btn, char *out, int out_len)
{
    if (!out || out_len <= 0) return ESP_ERR_INVALID_ARG;

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    const btn_map_t *m = &s_cfg.map[bank][page][btn];

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "pressMode",  (int)m->press_mode);
    cJSON_AddNumberToObject(root, "ccBehavior", (int)m->cc_behavior);

    cJSON *sa = cJSON_CreateArray();
    cJSON *la = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "short", sa);
    cJSON_AddItemToObject(root, "long",  la);

    for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(sa, &m->short_actions[i]);
    for (int i = 0; i < MAX_ACTIONS; i++) action_to_json(la, &m->long_actions[i]);

    char *s = cJSON_PrintUnformatted(root);
    cJSON_Delete(root);
    if (!s) return ESP_FAIL;

    int need = (int)strlen(s);
    if (need >= out_len) {
        free(s);
        return ESP_FAIL;
    }

    strcpy(out, s);
    free(s);
    return ESP_OK;
}

esp_err_t config_store_set_btn_json(int bank, int page, int btn, const char *json)
{
    if (!json) return ESP_ERR_INVALID_ARG;

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    cJSON *root = cJSON_Parse(json);
    if (!root) return ESP_FAIL;

    cJSON *pm = cJSON_GetObjectItem(root, "pressMode");
    cJSON *cb = cJSON_GetObjectItem(root, "ccBehavior");
    cJSON *sa = cJSON_GetObjectItem(root, "short");
    cJSON *la = cJSON_GetObjectItem(root, "long");

    if (!cJSON_IsNumber(pm) || !cJSON_IsNumber(cb) || !cJSON_IsArray(sa) || !cJSON_IsArray(la)) {
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    btn_map_t *m = &s_cfg.map[bank][page][btn];

    // NOTE: ตรงนี้ตอนนี้คุณ clamp 0..1 => เลยเหลือ “2 โหมด” อย่างที่คุณเจอ
    // ถ้าคุณเพิ่มโหมดกด 3 แบบ ต้องขยาย enum ใน header แล้วค่อยปรับ clamp เป็น 0..2
    int pressMode = clampi(pm->valueint, 0, 1);
    int ccBeh     = clampi(cb->valueint, 0, 2);
    m->press_mode  = (btn_press_mode_t)pressMode;
    m->cc_behavior = (cc_behavior_t)ccBeh;

    for (int i = 0; i < MAX_ACTIONS; i++) {
        set_default_action(&m->short_actions[i]);
        set_default_action(&m->long_actions[i]);
    }

    int ns = cJSON_GetArraySize(sa);
    if (ns > MAX_ACTIONS) ns = MAX_ACTIONS;
    for (int i = 0; i < ns; i++) {
        if (!parse_action(cJSON_GetArrayItem(sa, i), &m->short_actions[i])) {
            cJSON_Delete(root);
            return ESP_FAIL;
        }
    }

    int nl = cJSON_GetArraySize(la);
    if (nl > MAX_ACTIONS) nl = MAX_ACTIONS;
    for (int i = 0; i < nl; i++) {
        if (!parse_action(cJSON_GetArrayItem(la, i), &m->long_actions[i])) {
            cJSON_Delete(root);
            return ESP_FAIL;
        }
    }

    cJSON_Delete(root);
    return nvs_save_blob(&s_cfg);
}

===== END FILE: main\config_store.c =====

===== FILE: main\config_store.h =====
#pragma once
#include "esp_err.h"
#include <stdint.h>

#define MAX_BANKS   20
#define MAX_PAGES   4
#define NUM_BTNS    8
#define MAX_ACTIONS 8

#define NAME_LEN    16   // รวม '\0' แล้ว

typedef enum {
    ACT_NONE = 0,
    ACT_CC,
    ACT_PC,
    ACT_NOTE,
    ACT_DELAY,
    ACT_BANK_PC,   // CC0+CC32+PC
} action_type_t;

// Press mode:
// 0) Immediate: กดแล้วทำงานทันที (ใช้ short_actions)
// 1) Short+Long: สั้น=ปล่อยก่อน 500ms (short_actions), ยาว=ครบ 500ms ทำงานทันที (long_actions)
typedef enum {
    BTN_IMMEDIATE  = 0,
    BTN_SHORT_LONG = 1,
} btn_press_mode_t;

// CC behavior (ระดับปุ่ม):
// - Normal: ส่งค่าเดียว (ใช้ b)
// - Toggle: สลับ b <-> c ทุกครั้งที่กด (ถ้า c=0 จะถือเป็น 0)
// - Momentary: ตอนกด(Down) ส่ง b, ตอนปล่อย(Up) ส่ง c (ถ้า c=0 จะถือเป็น 0)
typedef enum {
    CC_NORMAL    = 0,
    CC_TOGGLE    = 1,
    CC_MOMENTARY = 2,
} cc_behavior_t;

// action fields (compact):
// - CC:      ch, a=cc,  b=valA, c=valB (toggle/momentary) หรือ unused (normal)
// - PC:      ch, a=pc
// - NOTE:    ch, a=note, b=vel, c=dur*10ms (สำหรับ NOTE แบบ one-shot)
// - DELAY:   ch ignored, a=ms_hi, b=ms_lo
// - BANK_PC: ch, a=pc, b=lsb, c=msb
typedef struct {
    action_type_t type;
    uint8_t ch;      // 1..16
    uint8_t a;
    uint8_t b;
    uint8_t c;
} action_t;

typedef struct {
    btn_press_mode_t press_mode;
    cc_behavior_t cc_behavior;
    action_t short_actions[MAX_ACTIONS];
    action_t long_actions[MAX_ACTIONS];
} btn_map_t;

typedef struct {
    // layout (ผู้ใช้แก้ได้ผ่านเว็บ)
    uint8_t bank_count;                       // 1..MAX_BANKS
    uint8_t page_count[MAX_BANKS];            // 1..MAX_PAGES ต่อ bank
    char    bank_name[MAX_BANKS][NAME_LEN];
    char    page_name[MAX_BANKS][MAX_PAGES][NAME_LEN];

    // mapping
    btn_map_t map[MAX_BANKS][MAX_PAGES][NUM_BTNS];
} foot_config_t;

// ---- init/load/save ----
void config_store_init(void);
const foot_config_t *config_store_get(void);

// ---- layout helpers ----
int  config_store_bank_count(void);
int  config_store_page_count(int bank);
const char *config_store_bank_name(int bank);
const char *config_store_page_name(int bank, int page);

esp_err_t config_store_get_layout_json(char *out, int out_len);
esp_err_t config_store_set_layout_json(const char *json);

// ---- per-button JSON (web-safe) ----
esp_err_t config_store_get_btn_json(int bank, int page, int btn, char *out, int out_len);
esp_err_t config_store_set_btn_json(int bank, int page, int btn, const char *json);

===== END FILE: main\config_store.h =====

===== FILE: main\dns_hijack.c =====
#include <string.h>
#include <arpa/inet.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "lwip/sockets.h"
#include "esp_log.h"

static const char *TAG = "DNS";

static void dns_task(void *arg)
{
    (void)arg;

    int s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0) {
        vTaskDelete(NULL);
        return;
    }

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(53);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(s, (struct sockaddr*)&addr, sizeof(addr));

    uint8_t buf[512];

    while (1) {
        struct sockaddr_in from = {0};
        socklen_t flen = sizeof(from);
        int n = recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&from, &flen);
        if (n < 12) continue;

        // Minimal DNS response:
        uint8_t out[512];
        memcpy(out, buf, n);

        // Header: set QR=1 response, RCODE=0, ANCOUNT=1
        out[2] = 0x81;
        out[3] = 0x80;
        out[6] = 0x00; out[7] = 0x01;

        // Answer:
        // NAME pointer 0xC00C, TYPE=A, CLASS=IN, TTL=60, RDLEN=4, RDATA=192.168.4.1
        int p = n;
        out[p++] = 0xC0; out[p++] = 0x0C;
        out[p++] = 0x00; out[p++] = 0x01;
        out[p++] = 0x00; out[p++] = 0x01;
        out[p++] = 0x00; out[p++] = 0x00; out[p++] = 0x00; out[p++] = 0x3C;
        out[p++] = 0x00; out[p++] = 0x04;
        out[p++] = 192; out[p++] = 168; out[p++] = 4; out[p++] = 1;

        sendto(s, out, p, 0, (struct sockaddr*)&from, flen);
    }
}

void dns_hijack_start(void)
{
    xTaskCreate(dns_task, "dns_hijack", 4096, NULL, 5, NULL);
    ESP_LOGI(TAG, "DNS hijack started");
}

===== END FILE: main\dns_hijack.c =====

===== FILE: main\dns_hijack.h =====
#pragma once
void dns_hijack_start(void);

===== END FILE: main\dns_hijack.h =====

===== FILE: main\footswitch.c =====
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "driver/gpio.h"

#include "footswitch.h"
#include "config_store.h"
#include "midi_actions.h"

static const gpio_num_t sw_pins[8] = {
    (gpio_num_t)4, (gpio_num_t)5, (gpio_num_t)6, (gpio_num_t)7,
    (gpio_num_t)15,(gpio_num_t)16,(gpio_num_t)17,(gpio_num_t)18
};

static footswitch_state_t s_state = {0, 0};

static inline int wrapi(int v, int max)
{
    if (max <= 0) return 0;
    int r = v % max;
    if (r < 0) r += max;
    return r;
}

static inline int pressed(int idx) { return gpio_get_level(sw_pins[idx]) == 0; } // pull-up: pressed=0

footswitch_state_t footswitch_get_state(void) { return s_state; }

void footswitch_set_state(int bank, int page)
{
    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);

    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);

    s_state.bank = (uint8_t)bank;
    s_state.page = (uint8_t)page;
}

static void run_actions_trigger(int btn_index_0_7, int is_long)
{
    const foot_config_t *cfg = config_store_get();
    const btn_map_t *m = &cfg->map[s_state.bank][s_state.page][btn_index_0_7];

    const action_t *list = is_long ? m->long_actions : m->short_actions;
    midi_actions_run(list, MAX_ACTIONS, m->cc_behavior, MIDI_EVT_TRIGGER);
}

static void run_actions_down_up(int btn_index_0_7, int event)
{
    const foot_config_t *cfg = config_store_get();
    const btn_map_t *m = &cfg->map[s_state.bank][s_state.page][btn_index_0_7];

    // momentary ใช้ short_actions เป็นหลัก
    midi_actions_run(m->short_actions, MAX_ACTIONS, m->cc_behavior, event);
}

// combo:
// 5&6 -> bank--
// 7&8 -> bank++
// 6&7 -> page++
static uint8_t s_combo_mask = 0;

static void apply_combo_logic(void)
{
    int b5 = pressed(4);
    int b6 = pressed(5);
    int b7 = pressed(6);
    int b8 = pressed(7);

    static int lock = 0;

    if (!b5 && !b6 && !b7 && !b8) {
        lock = 0;
        s_combo_mask = 0;
        return;
    }
    if (lock) return;

    int bc = config_store_bank_count();

    if (b5 && b6) {
        footswitch_set_state((int)s_state.bank - 1, (int)s_state.page);
        s_combo_mask = (1u << 4) | (1u << 5);
        lock = 1;
        return;
    }
    if (b7 && b8) {
        footswitch_set_state((int)s_state.bank + 1, (int)s_state.page);
        s_combo_mask = (1u << 6) | (1u << 7);
        lock = 1;
        return;
    }
    if (b6 && b7) {
        // page++ within current bank's pageCount
        int bank = (int)s_state.bank;
        int pc = config_store_page_count(bank);
        footswitch_set_state(bank, wrapi((int)s_state.page + 1, pc));
        s_combo_mask = (1u << 5) | (1u << 6);
        lock = 1;
        return;
    }

    (void)bc;
}

static void foot_task(void *arg)
{
    (void)arg;

    gpio_config_t io = {
        .pin_bit_mask = 0,
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = 1,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE,
    };
    for (int i = 0; i < 8; i++) io.pin_bit_mask |= (1ULL << sw_pins[i]);
    gpio_config(&io);

    uint8_t last[8];
    for (int i = 0; i < 8; i++) last[i] = 1;

    const int LONG_MS = 500;
    int hold_ms[8] = {0};
    uint8_t long_fired[8] = {0};

    while (1) {
        apply_combo_logic();

        for (int i = 0; i < 8; i++) {
            int now = gpio_get_level(sw_pins[i]); // 0 pressed, 1 released
            const foot_config_t *cfg = config_store_get();
            const btn_map_t *m = &cfg->map[s_state.bank][s_state.page][i];

            // ถ้าเป็นปุ่มคอมโบ -> ไม่ให้ยิง action
            if (s_combo_mask & (1u << i)) {
                last[i] = (uint8_t)now;
                hold_ms[i] = 0;
                long_fired[i] = 0;
                continue;
            }

            // edge: down
            if (last[i] == 1 && now == 0) {
                hold_ms[i] = 0;
                long_fired[i] = 0;

                // momentary: DOWN (ทันที) ไม่ผูกกับ press_mode
                if (m->cc_behavior == CC_MOMENTARY) {
                    run_actions_down_up(i, MIDI_EVT_DOWN);
                }

                // press mode immediate: trigger short immediately
                if (m->press_mode == BTN_IMMEDIATE) {
                    run_actions_trigger(i, 0);
                }
            }

            // hold
            if (now == 0) {
                hold_ms[i] += 10;

                // press mode short+long: long fires immediately at >=500ms (ครั้งเดียว)
                if (m->press_mode == BTN_SHORT_LONG && !long_fired[i] && hold_ms[i] >= LONG_MS) {
                    run_actions_trigger(i, 1);
                    long_fired[i] = 1;
                }
            }

            // edge: up
            if (last[i] == 0 && now == 1) {
                // momentary: UP
                if (m->cc_behavior == CC_MOMENTARY) {
                    run_actions_down_up(i, MIDI_EVT_UP);
                }

                // short+long: short fires on release only if not long-fired
                if (m->press_mode == BTN_SHORT_LONG) {
                    if (!long_fired[i] && hold_ms[i] < LONG_MS) {
                        run_actions_trigger(i, 0);
                    }
                }

                hold_ms[i] = 0;
                long_fired[i] = 0;
            }

            last[i] = (uint8_t)now;
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void footswitch_start(void)
{
    xTaskCreatePinnedToCore(foot_task, "footswitch", 4096, NULL, 6, NULL, 1);
}

===== END FILE: main\footswitch.c =====

===== FILE: main\footswitch.h =====
#pragma once
#include <stdint.h>

typedef struct {
    uint8_t bank; // 0..bankCount-1
    uint8_t page; // 0..pageCount(bank)-1
} footswitch_state_t;

void footswitch_start(void);

footswitch_state_t footswitch_get_state(void);
void footswitch_set_state(int bank, int page);

===== END FILE: main\footswitch.h =====

===== FILE: main\midi_actions.c =====
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "midi_actions.h"
#include "usb_midi_host.h"

// toggle state per (ch,cc)
static uint8_t s_toggle[16][128];

static uint8_t clamp7(int v) { if (v < 0) return 0; if (v > 127) return 127; return (uint8_t)v; }
static uint8_t clampCh(int v) { if (v < 1) return 1; if (v > 16) return 16; return (uint8_t)v; }

void midi_actions_run(const action_t *actions, int n, cc_behavior_t cc_behavior, int event)
{
    // ไม่พร้อมส่ง -> drop ทั้ง macro
    if (!usb_midi_ready_fast()) return;

    for (int i = 0; i < n; i++) {
        const action_t *a = &actions[i];
        if (a->type == ACT_NONE) continue;

        uint8_t ch = clampCh(a->ch);

        if (a->type == ACT_DELAY) {
            if (event != MIDI_EVT_TRIGGER) continue;
            int ms = ((int)a->a << 8) | (int)a->b;
            if (ms < 0) ms = 0;
            vTaskDelay(pdMS_TO_TICKS(ms));
            continue;
        }

        if (a->type == ACT_CC) {
            uint8_t cc = clamp7(a->a);
            uint8_t valA = clamp7(a->b);
            uint8_t valB = clamp7(a->c); // toggle/momentary second value

            if (cc_behavior == CC_NORMAL) {
                if (event != MIDI_EVT_TRIGGER) continue;
                (void)usb_midi_send_cc(ch, cc, valA);
            } else if (cc_behavior == CC_TOGGLE) {
                if (event != MIDI_EVT_TRIGGER) continue;
                uint8_t *st = &s_toggle[ch - 1][cc];
                *st = !(*st);
                uint8_t v0 = valA;
                uint8_t v1 = (a->c == 0) ? 0 : valB;
                (void)usb_midi_send_cc(ch, cc, (*st) ? v0 : v1);
            } else if (cc_behavior == CC_MOMENTARY) {
                // DOWN -> valA, UP -> valB(หรือ 0)
                if (event == MIDI_EVT_DOWN) {
                    (void)usb_midi_send_cc(ch, cc, valA);
                } else if (event == MIDI_EVT_UP) {
                    uint8_t v1 = (a->c == 0) ? 0 : valB;
                    (void)usb_midi_send_cc(ch, cc, v1);
                }
            }
            continue;
        }

        if (event != MIDI_EVT_TRIGGER) continue;

        if (a->type == ACT_PC) {
            uint8_t pc = clamp7(a->a);
            (void)usb_midi_send_pc(ch, pc);
            continue;
        }

        if (a->type == ACT_BANK_PC) {
            uint8_t pc  = clamp7(a->a);
            uint8_t lsb = clamp7(a->b);
            uint8_t msb = clamp7(a->c);

            (void)usb_midi_send_cc(ch, 0, msb);
            vTaskDelay(pdMS_TO_TICKS(2));
            (void)usb_midi_send_cc(ch, 32, lsb);
            vTaskDelay(pdMS_TO_TICKS(2));
            (void)usb_midi_send_pc(ch, pc);
            continue;
        }

        if (a->type == ACT_NOTE) {
            uint8_t note = clamp7(a->a);
            uint8_t vel  = clamp7(a->b);
            int dur = (a->c == 0) ? 50 : (int)a->c * 10;

            (void)usb_midi_send_note_on(ch, note, vel);
            vTaskDelay(pdMS_TO_TICKS(dur));
            (void)usb_midi_send_note_off(ch, note, 0);
            continue;
        }
    }
}

===== END FILE: main\midi_actions.c =====

===== FILE: main\midi_actions.h =====
#pragma once
#include "config_store.h"

// event:
#define MIDI_EVT_TRIGGER 0  // one-shot (short/long/immediate)
#define MIDI_EVT_DOWN    1  // press-down
#define MIDI_EVT_UP      2  // release

void midi_actions_run(const action_t *actions, int n, cc_behavior_t cc_behavior, int event);

===== END FILE: main\midi_actions.h =====

===== FILE: main\my_app.c =====
#include <stdio.h>
#include <string.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"

#include "esp_log.h"
#include "esp_err.h"

#include "driver/gpio.h"

#include "usb/usb_host.h"
#include "usb/usb_types_ch9.h"

static const char *TAG = "USB_MIDI_HOST";

// ส่งซ้ำทุก cable เผื่ออุปกรณ์รับไม่ใช่ cable 0 (ตั้ง 0 ก่อน ถ้าไม่ติดค่อยลอง 1)
#define SEND_ALL_CABLES   0

// -------------------- GPIO buttons (แก้ pin ตามบอร์ดคุณได้) --------------------
static const gpio_num_t sw_pins[8] = {
    (gpio_num_t)4, (gpio_num_t)5, (gpio_num_t)6, (gpio_num_t)7,
    (gpio_num_t)15,(gpio_num_t)16,(gpio_num_t)17,(gpio_num_t)18
};

// -------------------- CC request queue --------------------
typedef struct {
    uint8_t ch;   // 1..16
    uint8_t cc;   // 0..127
    uint8_t val;  // 0..127
} midi_cc_req_t;

static QueueHandle_t s_cc_queue;

// -------------------- USB host state --------------------
typedef struct {
    usb_host_client_handle_t client_hdl;
    usb_device_handle_t dev_hdl;

    bool have_device;
    bool claimed;
    uint8_t dev_addr;

    uint8_t midi_intf_num;
    uint8_t midi_ep_out;

    usb_transfer_t *xfer;
    SemaphoreHandle_t tx_done_sem;
} usb_midi_host_t;

static usb_midi_host_t s_usb;

// event flags from callback -> handled in client task (หลีกเลี่ยงทำงานหนักใน callback)
static volatile bool s_evt_new_dev = false;
static volatile bool s_evt_dev_gone = false;
static volatile uint8_t s_evt_new_addr = 0;

// Minimal header for walking descriptors
typedef struct __attribute__((packed)) {
    uint8_t bLength;
    uint8_t bDescriptorType;
} usb_desc_header_t;

// -------------------- USB Host daemon task --------------------
static void usb_host_daemon_task(void *arg)
{
    (void)arg;
    while (1) {
        uint32_t event_flags = 0;
        esp_err_t err = usb_host_lib_handle_events(portMAX_DELAY, &event_flags);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "usb_host_lib_handle_events err=%s", esp_err_to_name(err));
        }
    }
}

// -------------------- Find MIDI streaming interface + OUT endpoint --------------------
// Prefer BULK OUT, but accept INTERRUPT OUT if device uses it.
static bool find_midi_out_ep(const usb_config_desc_t *cfg, uint8_t *out_intf, uint8_t *out_ep)
{
    const uint8_t *p = (const uint8_t *)cfg;
    const uint8_t *end = p + cfg->wTotalLength;

    const usb_intf_desc_t *cur_intf = NULL;

    uint8_t found_intf = 0;
    uint8_t found_ep   = 0;
    bool found_bulk = false;

    while (p + sizeof(usb_desc_header_t) <= end) {
        const usb_desc_header_t *hdr = (const usb_desc_header_t *)p;
        if (hdr->bLength == 0) break;
        if (p + hdr->bLength > end) break;

        if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_INTERFACE) {
            cur_intf = (const usb_intf_desc_t *)p;

            // MIDI Streaming = Audio class(0x01), subclass(0x03)
            if (cur_intf->bInterfaceClass == 0x01 && cur_intf->bInterfaceSubClass == 0x03) {
                // keep candidate
            } else {
                cur_intf = NULL;
            }
        } else if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_ENDPOINT && cur_intf) {
            const usb_ep_desc_t *ep = (const usb_ep_desc_t *)p;

            uint8_t xfer_type = (ep->bmAttributes & 0x03);
            bool is_bulk      = (xfer_type == 0x02);
            bool is_interrupt = (xfer_type == 0x03);
            bool is_out       = ((ep->bEndpointAddress & 0x80) == 0x00);

            if (is_out && (is_bulk || is_interrupt)) {
                if (is_bulk) {
                    *out_intf = cur_intf->bInterfaceNumber;
                    *out_ep   = ep->bEndpointAddress;
                    return true;
                }
                if (!found_bulk) {
                    found_bulk = false;
                    found_intf = cur_intf->bInterfaceNumber;
                    found_ep   = ep->bEndpointAddress;
                }
            }
        }

        p += hdr->bLength;
    }

    if (found_ep) {
        *out_intf = found_intf;
        *out_ep   = found_ep;
        return true;
    }
    return false;
}

// -------------------- USB client event callback --------------------
static void client_event_cb(const usb_host_client_event_msg_t *event_msg, void *arg)
{
    (void)arg;
    if (event_msg->event == USB_HOST_CLIENT_EVENT_NEW_DEV) {
        s_evt_new_addr = event_msg->new_dev.address;
        s_evt_new_dev = true;
    } else if (event_msg->event == USB_HOST_CLIENT_EVENT_DEV_GONE) {
        s_evt_dev_gone = true;
    }
}

// -------------------- Transfer callback --------------------
static void transfer_cb(usb_transfer_t *transfer)
{
    if (transfer->status == USB_TRANSFER_STATUS_COMPLETED) {
        ESP_LOGI(TAG, "TX done (%d bytes)", (int)transfer->actual_num_bytes);
    } else {
        ESP_LOGW(TAG, "TX status=%d", (int)transfer->status);
    }
    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

// -------------------- Build USB-MIDI event packet for CC --------------------
// USB-MIDI event packet (4 bytes):
// [0]= (Cable<<4) | CIN ; [1]=status ; [2]=data1 ; [3]=data2
static void build_midi_cc_packet(uint8_t *pkt4, uint8_t cable, uint8_t ch_1_16, uint8_t cc, uint8_t val)
{
    if (ch_1_16 < 1) ch_1_16 = 1;
    if (ch_1_16 > 16) ch_1_16 = 16;

    uint8_t cin = 0x0B; // Control Change (3 bytes)

    // ✅ FIXED: byte0 = (Cable<<4) | CIN
    pkt4[0] = (uint8_t)(((cable & 0x0F) << 4) | (cin & 0x0F));
    pkt4[1] = (uint8_t)(0xB0 | ((ch_1_16 - 1) & 0x0F));
    pkt4[2] = (uint8_t)(cc & 0x7F);
    pkt4[3] = (uint8_t)(val & 0x7F);
}

// -------------------- Fast readiness check (ไม่ไปยุ่ง USB stack) --------------------
static inline bool midi_ready_fast(void)
{
    return (s_usb.have_device &&
            s_usb.dev_hdl != NULL &&
            s_usb.claimed &&
            s_usb.xfer != NULL &&
            s_usb.midi_ep_out != 0);
}

// -------------------- Cleanly close device --------------------
static void midi_close_device(void)
{
    // ✅ ไม่ส่งย้อนหลัง: ล้างคิวทันทีเมื่อหลุด
    if (s_cc_queue) {
        xQueueReset(s_cc_queue);
    }

    if (!s_usb.dev_hdl) {
        s_usb.have_device = false;
        s_usb.claimed = false;
        s_usb.midi_ep_out = 0;
        s_usb.midi_intf_num = 0;
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
        return;
    }

    // พยายามหยุด/flush endpoint (กันค้าง)
    if (s_usb.midi_ep_out) {
        (void)usb_host_endpoint_halt(s_usb.dev_hdl, s_usb.midi_ep_out);
        (void)usb_host_endpoint_flush(s_usb.dev_hdl, s_usb.midi_ep_out);
    }

    // release interface ก่อน close
    if (s_usb.claimed) {
        (void)usb_host_interface_release(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num);
        s_usb.claimed = false;
    }

    // close device
    (void)usb_host_device_close(s_usb.client_hdl, s_usb.dev_hdl);
    s_usb.dev_hdl = NULL;

    // clear state
    s_usb.have_device = false;
    s_usb.midi_ep_out = 0;
    s_usb.midi_intf_num = 0;

    if (s_usb.xfer) {
        s_usb.xfer->device_handle = NULL;
        s_usb.xfer->bEndpointAddress = 0;
    }

    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

// -------------------- Ensure device opened + interface claimed + endpoint found --------------------
static esp_err_t ensure_midi_ready(void)
{
    if (!s_usb.have_device) return ESP_ERR_INVALID_STATE;

    if (s_usb.dev_hdl == NULL) {
        esp_err_t e = usb_host_device_open(s_usb.client_hdl, s_usb.dev_addr, &s_usb.dev_hdl);
        if (e != ESP_OK) return e;

        const usb_config_desc_t *cfg_desc = NULL;
        e = usb_host_get_active_config_descriptor(s_usb.dev_hdl, &cfg_desc);
        if (e != ESP_OK) {
            midi_close_device();
            return e;
        }

        uint8_t intf = 0, ep_out = 0;
        if (!find_midi_out_ep(cfg_desc, &intf, &ep_out)) {
            ESP_LOGE(TAG, "No MIDI OUT endpoint found");
            midi_close_device();
            return ESP_FAIL;
        }

        s_usb.midi_intf_num = intf;
        s_usb.midi_ep_out   = ep_out;

        ESP_LOGI(TAG, "MIDI found: intf=%u ep_out=0x%02X", s_usb.midi_intf_num, s_usb.midi_ep_out);

        e = usb_host_interface_claim(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num, 0);
        if (e != ESP_OK) {
            midi_close_device();
            return e;
        }
        s_usb.claimed = true;

        if (s_usb.xfer == NULL) {
            e = usb_host_transfer_alloc(64, 0, &s_usb.xfer);
            if (e != ESP_OK) {
                midi_close_device();
                return e;
            }
            s_usb.xfer->callback = transfer_cb;
            s_usb.xfer->context = NULL;
        }
        s_usb.xfer->device_handle = s_usb.dev_hdl;
        s_usb.xfer->bEndpointAddress = s_usb.midi_ep_out;
    }

    return ESP_OK;
}

// -------------------- Send CC (host -> device) --------------------
static esp_err_t usb_midi_send_cc(uint8_t ch, uint8_t cc, uint8_t val)
{
    esp_err_t ready = ensure_midi_ready();
    if (ready != ESP_OK) return ready;

    if (s_usb.tx_done_sem) xSemaphoreTake(s_usb.tx_done_sem, pdMS_TO_TICKS(1000));

#if SEND_ALL_CABLES
    for (uint8_t cable = 0; cable < 16; cable++) {
        uint8_t pkt[4];
        build_midi_cc_packet(pkt, cable, ch, cc, val);

        memcpy(s_usb.xfer->data_buffer, pkt, 4);
        s_usb.xfer->num_bytes = 4;

        esp_err_t err = usb_host_transfer_submit(s_usb.xfer);
        if (err != ESP_OK) {
            if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
            return err;
        }

        if (s_usb.tx_done_sem) xSemaphoreTake(s_usb.tx_done_sem, pdMS_TO_TICKS(1000));
        vTaskDelay(pdMS_TO_TICKS(2));
    }
    return ESP_OK;
#else
    uint8_t pkt[4];
    build_midi_cc_packet(pkt, 0, ch, cc, val);

    memcpy(s_usb.xfer->data_buffer, pkt, 4);
    s_usb.xfer->num_bytes = 4;

    esp_err_t err = usb_host_transfer_submit(s_usb.xfer);
    if (err != ESP_OK) {
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
    }
    return err;
#endif
}

// -------------------- Button task: press -> increment val; send only if ready --------------------
static void button_task(void *arg)
{
    (void)arg;

    uint8_t last[8];
    for (int i = 0; i < 8; i++) last[i] = 1;

    // GP-50: CC0 = 0..99 (Patch 00..99)
    uint8_t val = 0;

    while (1) {
        for (int i = 0; i < 8; i++) {
            int now = gpio_get_level(sw_pins[i]); // INPUT_PULLUP: pressed=0
            if (last[i] == 1 && now == 0) {
                // wait release (simple debounce)
                while (gpio_get_level(sw_pins[i]) == 0) vTaskDelay(pdMS_TO_TICKS(10));

                // ✅ กดแล้ว "นับค่า" ไปเรื่อย ๆ เสมอ
                midi_cc_req_t req = { .ch = 1, .cc = 0, .val = val };

                // ✅ เงื่อนไขสำคัญ:
                // ถ้า USB-MIDI ไม่ ready -> ไม่เก็บ ไม่ enqueue ไม่ส่งย้อนหลัง
                if (midi_ready_fast()) {
                    // ถ้าคิวเต็มทิ้งอันเก่าสุด
                    if (uxQueueSpacesAvailable(s_cc_queue) == 0) {
                        midi_cc_req_t dummy;
                        (void)xQueueReceive(s_cc_queue, &dummy, 0);
                    }
                    (void)xQueueSend(s_cc_queue, &req, 0);
                }

                val++;
                if (val > 99) val = 0;
            }
            last[i] = (uint8_t)now;
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// -------------------- USB client task --------------------
static void usb_client_task(void *arg)
{
    (void)arg;

    usb_host_client_config_t client_cfg = {
        .is_synchronous = false,
        .max_num_event_msg = 5,
        .async = {
            .client_event_callback = client_event_cb,
            .callback_arg = NULL,
        },
    };

    ESP_ERROR_CHECK(usb_host_client_register(&client_cfg, &s_usb.client_hdl));
    ESP_LOGI(TAG, "USB client registered");

    while (1) {
        usb_host_client_handle_events(s_usb.client_hdl, pdMS_TO_TICKS(20));

        // handle DEV_GONE safely here
        if (s_evt_dev_gone) {
            s_evt_dev_gone = false;
            ESP_LOGW(TAG, "DEV_GONE");
            midi_close_device();
        }

        // handle NEW_DEV safely here
        if (s_evt_new_dev) {
            s_evt_new_dev = false;
            s_usb.dev_addr = s_evt_new_addr;
            s_usb.have_device = true;
            ESP_LOGI(TAG, "NEW_DEV addr=%u", s_usb.dev_addr);
        }

        // warm-up: ถ้ามีอุปกรณ์เสียบแล้วแต่ยังไม่ open/claim ให้เตรียมไว้
        if (s_usb.have_device && s_usb.dev_hdl == NULL) {
            (void)ensure_midi_ready();
        }

        // send queued requests (เฉพาะที่กดตอน ready)
        midi_cc_req_t req;
        if (xQueueReceive(s_cc_queue, &req, 0) == pdTRUE) {
            esp_err_t err = usb_midi_send_cc(req.ch, req.cc, req.val);
            // ถ้าส่งไม่ผ่านก็ทิ้งเลย (ไม่ส่งย้อนหลัง)
            (void)err;
        }

        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

void app_main(void)
{
    gpio_config_t io = {
        .pin_bit_mask = 0,
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = 1,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE,
    };
    for (int i = 0; i < 8; i++) {
        io.pin_bit_mask |= (1ULL << sw_pins[i]);
    }
    ESP_ERROR_CHECK(gpio_config(&io));

    s_cc_queue = xQueueCreate(64, sizeof(midi_cc_req_t));

    s_usb.tx_done_sem = xSemaphoreCreateBinary();
    xSemaphoreGive(s_usb.tx_done_sem);

    usb_host_config_t host_cfg = {
        .intr_flags = ESP_INTR_FLAG_LEVEL1,
    };
    ESP_ERROR_CHECK(usb_host_install(&host_cfg));
    ESP_LOGI(TAG, "USB Host installed");

    xTaskCreatePinnedToCore(usb_host_daemon_task, "usb_daemon", 4096, NULL, 20, NULL, 0);
    xTaskCreatePinnedToCore(usb_client_task, "usb_client", 8192, NULL, 15, NULL, 1);
    xTaskCreatePinnedToCore(button_task, "buttons", 4096, NULL, 5, NULL, 1);

    ESP_LOGI(TAG, "Ready. Press button to send CC0 val 0..99 (no buffering when disconnected)");
}

===== END FILE: main\my_app.c =====

===== FILE: main\portal_wifi.c =====
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "esp_log.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_http_server.h"
#include "esp_spiffs.h"
#include "cJSON.h"

#include "dns_hijack.h"
#include "config_store.h"
#include "footswitch.h"

static const char *TAG = "PORTAL";
static httpd_handle_t s_http = NULL;

static inline int wrapi(int v, int max)
{
    if (max <= 0) return 0;
    int r = v % max;
    if (r < 0) r += max;
    return r;
}

static esp_err_t send_spiffs_file(httpd_req_t *req, const char *path, const char *ctype)
{
    FILE *f = fopen(path, "rb");
    if (!f) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "file not found");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, ctype);

    char buf[1024];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
        if (httpd_resp_send_chunk(req, buf, n) != ESP_OK) {
            fclose(f);
            httpd_resp_sendstr_chunk(req, NULL);
            return ESP_FAIL;
        }
    }

    fclose(f);
    httpd_resp_sendstr_chunk(req, NULL);
    return ESP_OK;
}

// -------- Static files --------
static esp_err_t h_root(httpd_req_t *req) { return send_spiffs_file(req, "/spiffs/index.html", "text/html"); }
static esp_err_t h_js(httpd_req_t *req)   { return send_spiffs_file(req, "/spiffs/app.js", "application/javascript"); }
static esp_err_t h_css(httpd_req_t *req)  { return send_spiffs_file(req, "/spiffs/style.css", "text/css"); }

// -------- Captive portal detection endpoints (redirect to /) --------
static esp_err_t h_redirect_to_root(httpd_req_t *req)
{
    httpd_resp_set_status(req, "302 Found");
    httpd_resp_set_hdr(req, "Location", "/");
    httpd_resp_send(req, NULL, 0);
    return ESP_OK;
}

static esp_err_t h_generate_204(httpd_req_t *req) { return h_redirect_to_root(req); }
static esp_err_t h_hotspot(httpd_req_t *req)      { return h_redirect_to_root(req); }
static esp_err_t h_ncsi(httpd_req_t *req)         { return h_redirect_to_root(req); }

// -------- API: META --------
static esp_err_t h_get_meta(httpd_req_t *req)
{
    char out[160];
    int bc = config_store_bank_count();
    snprintf(out, sizeof(out),
             "{\"maxBanks\":%d,\"maxPages\":%d,\"buttons\":%d,\"bankCount\":%d}",
             MAX_BANKS, MAX_PAGES, NUM_BTNS, bc);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    return ESP_OK;
}

// -------- API: LAYOUT --------
static esp_err_t h_get_layout(httpd_req_t *req)
{
    char json[4096];
    memset(json, 0, sizeof(json));
    if (config_store_get_layout_json(json, sizeof(json)) != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "layout read failed");
        return ESP_FAIL;
    }
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json);
    return ESP_OK;
}

static esp_err_t h_post_layout(httpd_req_t *req)
{
    int total = req->content_len;
    if (total <= 0 || total > 4096) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char *buf = (char *)calloc(1, total + 1);
    if (!buf) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            free(buf);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    esp_err_t e = config_store_set_layout_json(buf);
    free(buf);

    if (e != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "layout invalid");
        return ESP_FAIL;
    }

    // clamp current state after layout change
    footswitch_state_t st = footswitch_get_state();
    footswitch_set_state(st.bank, st.page);

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

// -------- API: state --------
static esp_err_t h_get_state(httpd_req_t *req)
{
    footswitch_state_t st = footswitch_get_state();
    char out[128];
    snprintf(out, sizeof(out), "{\"bank\":%u,\"page\":%u}", (unsigned)st.bank, (unsigned)st.page);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    return ESP_OK;
}

static esp_err_t h_post_state(httpd_req_t *req)
{
    int total = req->content_len;
    if (total <= 0 || total > 256) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char buf[257];
    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    cJSON *root = cJSON_Parse(buf);
    if (!root) { httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json"); return ESP_FAIL; }

    cJSON *jb = cJSON_GetObjectItem(root, "bank");
    cJSON *jp = cJSON_GetObjectItem(root, "page");
    if (!cJSON_IsNumber(jb) || !cJSON_IsNumber(jp)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json fields");
        return ESP_FAIL;
    }

    int bc = config_store_bank_count();
    int bank = wrapi(jb->valueint, bc);
    int pc = config_store_page_count(bank);
    int page = wrapi(jp->valueint, pc);

    footswitch_set_state(bank, page);
    cJSON_Delete(root);

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

// -------- API: per-button mapping --------
// GET  /api/button?bank=0&page=0&btn=0
static esp_err_t h_get_button(httpd_req_t *req)
{
    char q[96] = {0};
    int bank = 0, page = 0, btn = 0;

    if (httpd_req_get_url_query_str(req, q, sizeof(q)) == ESP_OK) {
        char tmp[16];
        if (httpd_query_key_value(q, "bank", tmp, sizeof(tmp)) == ESP_OK) bank = atoi(tmp);
        if (httpd_query_key_value(q, "page", tmp, sizeof(tmp)) == ESP_OK) page = atoi(tmp);
        if (httpd_query_key_value(q, "btn",  tmp, sizeof(tmp)) == ESP_OK) btn  = atoi(tmp);
    }

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    char json[2048];
    memset(json, 0, sizeof(json));
    if (config_store_get_btn_json(bank, page, btn, json, sizeof(json)) != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "button read failed");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, json);
    return ESP_OK;
}

// POST /api/button?bank=0&page=0&btn=0
static esp_err_t h_post_button(httpd_req_t *req)
{
    char q[96] = {0};
    int bank = 0, page = 0, btn = 0;

    if (httpd_req_get_url_query_str(req, q, sizeof(q)) == ESP_OK) {
        char tmp[16];
        if (httpd_query_key_value(q, "bank", tmp, sizeof(tmp)) == ESP_OK) bank = atoi(tmp);
        if (httpd_query_key_value(q, "page", tmp, sizeof(tmp)) == ESP_OK) page = atoi(tmp);
        if (httpd_query_key_value(q, "btn",  tmp, sizeof(tmp)) == ESP_OK) btn  = atoi(tmp);
    }

    int bc = config_store_bank_count();
    bank = wrapi(bank, bc);
    int pc = config_store_page_count(bank);
    page = wrapi(page, pc);
    btn  = wrapi(btn,  NUM_BTNS);

    int total = req->content_len;
    if (total <= 0 || total > 2048) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad body");
        return ESP_FAIL;
    }

    char *buf = (char *)calloc(1, total + 1);
    if (!buf) {
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "no mem");
        return ESP_FAIL;
    }

    int got = 0;
    while (got < total) {
        int r = httpd_req_recv(req, buf + got, total - got);
        if (r <= 0) {
            free(buf);
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "recv fail");
            return ESP_FAIL;
        }
        got += r;
    }
    buf[total] = 0;

    esp_err_t e = config_store_set_btn_json(bank, page, btn, buf);
    free(buf);

    if (e != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "button config invalid");
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"ok\":true}");
    return ESP_OK;
}

static void start_http_server(void)
{
    httpd_config_t cfg = HTTPD_DEFAULT_CONFIG();
    cfg.max_uri_handlers = 40;

    ESP_ERROR_CHECK(httpd_start(&s_http, &cfg));

    httpd_uri_t u_root = { .uri="/", .method=HTTP_GET, .handler=h_root };
    httpd_uri_t u_js   = { .uri="/app.js", .method=HTTP_GET, .handler=h_js };
    httpd_uri_t u_css  = { .uri="/style.css", .method=HTTP_GET, .handler=h_css };

    httpd_uri_t u_204  = { .uri="/generate_204", .method=HTTP_GET, .handler=h_generate_204 };
    httpd_uri_t u_hot  = { .uri="/hotspot-detect.html", .method=HTTP_GET, .handler=h_hotspot };
    httpd_uri_t u_ncsi = { .uri="/ncsi.txt", .method=HTTP_GET, .handler=h_ncsi };
    httpd_uri_t u_ct   = { .uri="/connecttest.txt", .method=HTTP_GET, .handler=h_ncsi };

    httpd_uri_t u_meta   = { .uri="/api/meta",   .method=HTTP_GET,  .handler=h_get_meta };
    httpd_uri_t u_layout = { .uri="/api/layout", .method=HTTP_GET,  .handler=h_get_layout };
    httpd_uri_t u_pl     = { .uri="/api/layout", .method=HTTP_POST, .handler=h_post_layout };

    httpd_uri_t u_gs   = { .uri="/api/state", .method=HTTP_GET,  .handler=h_get_state };
    httpd_uri_t u_ps   = { .uri="/api/state", .method=HTTP_POST, .handler=h_post_state };

    httpd_uri_t u_gb   = { .uri="/api/button", .method=HTTP_GET,  .handler=h_get_button };
    httpd_uri_t u_pb   = { .uri="/api/button", .method=HTTP_POST, .handler=h_post_button };

    httpd_register_uri_handler(s_http, &u_root);
    httpd_register_uri_handler(s_http, &u_js);
    httpd_register_uri_handler(s_http, &u_css);

    httpd_register_uri_handler(s_http, &u_204);
    httpd_register_uri_handler(s_http, &u_hot);
    httpd_register_uri_handler(s_http, &u_ncsi);
    httpd_register_uri_handler(s_http, &u_ct);

    httpd_register_uri_handler(s_http, &u_meta);
    httpd_register_uri_handler(s_http, &u_layout);
    httpd_register_uri_handler(s_http, &u_pl);

    httpd_register_uri_handler(s_http, &u_gs);
    httpd_register_uri_handler(s_http, &u_ps);

    httpd_register_uri_handler(s_http, &u_gb);
    httpd_register_uri_handler(s_http, &u_pb);

    ESP_LOGI(TAG, "HTTP server started");
}

static void mount_spiffs(void)
{
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = NULL,
        .max_files = 8,
        .format_if_mount_failed = true,
    };
    ESP_ERROR_CHECK(esp_vfs_spiffs_register(&conf));
    ESP_LOGI(TAG, "SPIFFS mounted");
}

void portal_wifi_start(void)
{
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    esp_netif_create_default_wifi_ap();

    wifi_init_config_t wicfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&wicfg));

    wifi_config_t ap = { 0 };
    strcpy((char*)ap.ap.ssid, "FOOTSWITCH-SETUP");
    strcpy((char*)ap.ap.password, "12345678");
    ap.ap.ssid_len = 0;
    ap.ap.max_connection = 2;
    ap.ap.authmode = WIFI_AUTH_WPA_WPA2_PSK;
    if (strlen((char*)ap.ap.password) == 0) ap.ap.authmode = WIFI_AUTH_OPEN;

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &ap));
    ESP_ERROR_CHECK(esp_wifi_start());

    mount_spiffs();

    dns_hijack_start();
    start_http_server();

    ESP_LOGI(TAG, "Captive portal ready. Connect Wi-Fi 'FOOTSWITCH-SETUP' then open 192.168.4.1");
}

===== END FILE: main\portal_wifi.c =====

===== FILE: main\portal_wifi.h =====
#pragma once
void portal_wifi_start(void);

===== END FILE: main\portal_wifi.h =====

===== FILE: main\usb_midi_host.c =====
#include <string.h>
#include <stdbool.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"

#include "esp_log.h"
#include "esp_err.h"

#include "usb/usb_host.h"
#include "usb/usb_types_ch9.h"

#include "usb_midi_host.h"

static const char *TAG = "USB_MIDI";

#define SEND_ALL_CABLES 0

typedef struct {
    usb_host_client_handle_t client_hdl;
    usb_device_handle_t dev_hdl;

    bool have_device;
    bool claimed;
    uint8_t dev_addr;

    uint8_t midi_intf_num;
    uint8_t midi_ep_out;

    usb_transfer_t *xfer;
    SemaphoreHandle_t tx_done_sem;
} usb_midi_host_state_t;

static usb_midi_host_state_t s_usb;

// event flags from callback -> handled in client task
static volatile bool s_evt_new_dev = false;
static volatile bool s_evt_dev_gone = false;
static volatile uint8_t s_evt_new_addr = 0;

// Minimal header for walking descriptors
typedef struct __attribute__((packed)) {
    uint8_t bLength;
    uint8_t bDescriptorType;
} usb_desc_header_t;

// -------------------- Transfer callback --------------------
static void transfer_cb(usb_transfer_t *transfer)
{
    if (transfer->status == USB_TRANSFER_STATUS_COMPLETED) {
        // ok
    } else {
        ESP_LOGW(TAG, "TX status=%d", (int)transfer->status);
    }
    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

// -------------------- USB client event callback --------------------
static void client_event_cb(const usb_host_client_event_msg_t *event_msg, void *arg)
{
    (void)arg;
    if (event_msg->event == USB_HOST_CLIENT_EVENT_NEW_DEV) {
        s_evt_new_addr = event_msg->new_dev.address;
        s_evt_new_dev = true;
    } else if (event_msg->event == USB_HOST_CLIENT_EVENT_DEV_GONE) {
        s_evt_dev_gone = true;
    }
}

// -------------------- Find MIDI streaming interface + OUT endpoint --------------------
static bool find_midi_out_ep(const usb_config_desc_t *cfg, uint8_t *out_intf, uint8_t *out_ep)
{
    const uint8_t *p = (const uint8_t *)cfg;
    const uint8_t *end = p + cfg->wTotalLength;

    const usb_intf_desc_t *cur_intf = NULL;

    uint8_t found_intf = 0;
    uint8_t found_ep   = 0;
    bool found_bulk = false;

    while (p + sizeof(usb_desc_header_t) <= end) {
        const usb_desc_header_t *hdr = (const usb_desc_header_t *)p;
        if (hdr->bLength == 0) break;
        if (p + hdr->bLength > end) break;

        if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_INTERFACE) {
            cur_intf = (const usb_intf_desc_t *)p;

            // MIDI Streaming = Audio class(0x01), subclass(0x03)
            if (cur_intf->bInterfaceClass == 0x01 && cur_intf->bInterfaceSubClass == 0x03) {
                // keep
            } else {
                cur_intf = NULL;
            }
        } else if (hdr->bDescriptorType == USB_B_DESCRIPTOR_TYPE_ENDPOINT && cur_intf) {
            const usb_ep_desc_t *ep = (const usb_ep_desc_t *)p;

            uint8_t xfer_type = (ep->bmAttributes & 0x03);
            bool is_bulk      = (xfer_type == 0x02);
            bool is_interrupt = (xfer_type == 0x03);
            bool is_out       = ((ep->bEndpointAddress & 0x80) == 0x00);

            if (is_out && (is_bulk || is_interrupt)) {
                if (is_bulk) {
                    *out_intf = cur_intf->bInterfaceNumber;
                    *out_ep   = ep->bEndpointAddress;
                    return true;
                }
                if (!found_bulk) {
                    found_bulk = false;
                    found_intf = cur_intf->bInterfaceNumber;
                    found_ep   = ep->bEndpointAddress;
                }
            }
        }
        p += hdr->bLength;
    }

    if (found_ep) {
        *out_intf = found_intf;
        *out_ep   = found_ep;
        return true;
    }
    return false;
}

static inline uint8_t clamp_ch(uint8_t ch_1_16)
{
    if (ch_1_16 < 1) return 1;
    if (ch_1_16 > 16) return 16;
    return ch_1_16;
}

// USB-MIDI event packet (4 bytes): [0]=(Cable<<4)|CIN [1]=status [2]=d1 [3]=d2
static inline void build_pkt_3b(uint8_t *pkt, uint8_t cable, uint8_t cin, uint8_t status, uint8_t d1, uint8_t d2)
{
    pkt[0] = (uint8_t)(((cable & 0x0F) << 4) | (cin & 0x0F));
    pkt[1] = status;
    pkt[2] = d1;
    pkt[3] = d2;
}
static inline void build_pkt_2b(uint8_t *pkt, uint8_t cable, uint8_t cin, uint8_t status, uint8_t d1)
{
    pkt[0] = (uint8_t)(((cable & 0x0F) << 4) | (cin & 0x0F));
    pkt[1] = status;
    pkt[2] = d1;
    pkt[3] = 0x00;
}

static void midi_close_device(void)
{
    if (!s_usb.dev_hdl) {
        s_usb.have_device = false;
        s_usb.claimed = false;
        s_usb.midi_ep_out = 0;
        s_usb.midi_intf_num = 0;
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
        return;
    }

    if (s_usb.midi_ep_out) {
        (void)usb_host_endpoint_halt(s_usb.dev_hdl, s_usb.midi_ep_out);
        (void)usb_host_endpoint_flush(s_usb.dev_hdl, s_usb.midi_ep_out);
    }

    if (s_usb.claimed) {
        (void)usb_host_interface_release(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num);
        s_usb.claimed = false;
    }

    (void)usb_host_device_close(s_usb.client_hdl, s_usb.dev_hdl);
    s_usb.dev_hdl = NULL;

    s_usb.have_device = false;
    s_usb.midi_ep_out = 0;
    s_usb.midi_intf_num = 0;

    if (s_usb.xfer) {
        s_usb.xfer->device_handle = NULL;
        s_usb.xfer->bEndpointAddress = 0;
    }

    if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
}

static esp_err_t ensure_midi_ready(void)
{
    if (!s_usb.have_device) return ESP_ERR_INVALID_STATE;

    if (s_usb.dev_hdl == NULL) {
        esp_err_t e = usb_host_device_open(s_usb.client_hdl, s_usb.dev_addr, &s_usb.dev_hdl);
        if (e != ESP_OK) return e;

        const usb_config_desc_t *cfg_desc = NULL;
        e = usb_host_get_active_config_descriptor(s_usb.dev_hdl, &cfg_desc);
        if (e != ESP_OK) { midi_close_device(); return e; }

        uint8_t intf = 0, ep_out = 0;
        if (!find_midi_out_ep(cfg_desc, &intf, &ep_out)) {
            ESP_LOGE(TAG, "No MIDI OUT endpoint found");
            midi_close_device();
            return ESP_FAIL;
        }

        s_usb.midi_intf_num = intf;
        s_usb.midi_ep_out = ep_out;

        e = usb_host_interface_claim(s_usb.client_hdl, s_usb.dev_hdl, s_usb.midi_intf_num, 0);
        if (e != ESP_OK) { midi_close_device(); return e; }
        s_usb.claimed = true;

        if (s_usb.xfer == NULL) {
            e = usb_host_transfer_alloc(64, 0, &s_usb.xfer);
            if (e != ESP_OK) { midi_close_device(); return e; }
            s_usb.xfer->callback = transfer_cb;
            s_usb.xfer->context = NULL;
        }

        s_usb.xfer->device_handle = s_usb.dev_hdl;
        s_usb.xfer->bEndpointAddress = s_usb.midi_ep_out;
    }

    return ESP_OK;
}

int usb_midi_ready_fast(void)
{
    return (s_usb.have_device &&
            s_usb.dev_hdl != NULL &&
            s_usb.claimed &&
            s_usb.xfer != NULL &&
            s_usb.midi_ep_out != 0);
}

static esp_err_t submit_pkt(const uint8_t pkt4[4])
{
    if (ensure_midi_ready() != ESP_OK) return ESP_ERR_INVALID_STATE;

    if (s_usb.tx_done_sem) xSemaphoreTake(s_usb.tx_done_sem, pdMS_TO_TICKS(1000));

    memcpy(s_usb.xfer->data_buffer, pkt4, 4);
    s_usb.xfer->num_bytes = 4;

    esp_err_t err = usb_host_transfer_submit(s_usb.xfer);
    if (err != ESP_OK) {
        if (s_usb.tx_done_sem) xSemaphoreGive(s_usb.tx_done_sem);
    }
    return err;
}

esp_err_t usb_midi_send_cc(uint8_t ch_1_16, uint8_t cc, uint8_t val)
{
    ch_1_16 = clamp_ch(ch_1_16);

#if SEND_ALL_CABLES
    esp_err_t last = ESP_OK;
    for (uint8_t cable = 0; cable < 16; cable++) {
        uint8_t pkt[4];
        build_pkt_3b(pkt, cable, 0x0B, (uint8_t)(0xB0 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(cc & 0x7F), (uint8_t)(val & 0x7F));
        last = submit_pkt(pkt);
        if (last != ESP_OK) break;
        vTaskDelay(pdMS_TO_TICKS(2));
    }
    return last;
#else
    uint8_t pkt[4];
    build_pkt_3b(pkt, 0, 0x0B, (uint8_t)(0xB0 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(cc & 0x7F), (uint8_t)(val & 0x7F));
    return submit_pkt(pkt);
#endif
}

esp_err_t usb_midi_send_pc(uint8_t ch_1_16, uint8_t pc)
{
    ch_1_16 = clamp_ch(ch_1_16);

    uint8_t pkt[4];
    // CIN 0x0C = Program Change (2 bytes)
    build_pkt_2b(pkt, 0, 0x0C, (uint8_t)(0xC0 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(pc & 0x7F));
    return submit_pkt(pkt);
}

esp_err_t usb_midi_send_note_on(uint8_t ch_1_16, uint8_t note, uint8_t vel)
{
    ch_1_16 = clamp_ch(ch_1_16);

    uint8_t pkt[4];
    // CIN 0x09 = Note On (3 bytes)
    build_pkt_3b(pkt, 0, 0x09, (uint8_t)(0x90 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(note & 0x7F), (uint8_t)(vel & 0x7F));
    return submit_pkt(pkt);
}

esp_err_t usb_midi_send_note_off(uint8_t ch_1_16, uint8_t note, uint8_t vel)
{
    ch_1_16 = clamp_ch(ch_1_16);

    uint8_t pkt[4];
    // CIN 0x08 = Note Off (3 bytes)
    build_pkt_3b(pkt, 0, 0x08, (uint8_t)(0x80 | ((ch_1_16 - 1) & 0x0F)), (uint8_t)(note & 0x7F), (uint8_t)(vel & 0x7F));
    return submit_pkt(pkt);
}

// -------------------- tasks --------------------
static void usb_host_daemon_task(void *arg)
{
    (void)arg;
    while (1) {
        uint32_t event_flags = 0;
        esp_err_t err = usb_host_lib_handle_events(portMAX_DELAY, &event_flags);
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "usb_host_lib_handle_events err=%s", esp_err_to_name(err));
        }
    }
}

static void usb_client_task(void *arg)
{
    (void)arg;

    usb_host_client_config_t client_cfg = {
        .is_synchronous = false,
        .max_num_event_msg = 8,
        .async = {
            .client_event_callback = client_event_cb,
            .callback_arg = NULL,
        },
    };

    ESP_ERROR_CHECK(usb_host_client_register(&client_cfg, &s_usb.client_hdl));
    ESP_LOGI(TAG, "USB client registered");

    while (1) {
        usb_host_client_handle_events(s_usb.client_hdl, pdMS_TO_TICKS(20));

        if (s_evt_dev_gone) {
            s_evt_dev_gone = false;
            ESP_LOGW(TAG, "DEV_GONE");
            midi_close_device();
        }

        if (s_evt_new_dev) {
            s_evt_new_dev = false;
            s_usb.dev_addr = s_evt_new_addr;
            s_usb.have_device = true;
            ESP_LOGI(TAG, "NEW_DEV addr=%u", s_usb.dev_addr);
            (void)ensure_midi_ready();
        }

        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

void usb_midi_host_init(void)
{
    // binary semaphore for TX serialize
    s_usb.tx_done_sem = xSemaphoreCreateBinary();
    xSemaphoreGive(s_usb.tx_done_sem);

    usb_host_config_t host_cfg = {
        .intr_flags = ESP_INTR_FLAG_LEVEL1,
    };
    ESP_ERROR_CHECK(usb_host_install(&host_cfg));
    ESP_LOGI(TAG, "USB Host installed");

    xTaskCreatePinnedToCore(usb_host_daemon_task, "usb_daemon", 4096, NULL, 20, NULL, 0);
    xTaskCreatePinnedToCore(usb_client_task, "usb_client", 8192, NULL, 15, NULL, 1);
}

===== END FILE: main\usb_midi_host.c =====

===== FILE: main\usb_midi_host.h =====
#pragma once
#include <stdint.h>
#include "esp_err.h"

void usb_midi_host_init(void);

// ready check
int usb_midi_ready_fast(void);

// sending
esp_err_t usb_midi_send_cc(uint8_t ch_1_16, uint8_t cc, uint8_t val);
esp_err_t usb_midi_send_pc(uint8_t ch_1_16, uint8_t pc);
esp_err_t usb_midi_send_note_on(uint8_t ch_1_16, uint8_t note, uint8_t vel);
esp_err_t usb_midi_send_note_off(uint8_t ch_1_16, uint8_t note, uint8_t vel);

===== END FILE: main\usb_midi_host.h =====

===== FILE: spiffs\app.js =====
const $ = (id) => document.getElementById(id);

let META = { maxBanks: 20, maxPages: 4, buttons: 8, bankCount: 20 };
let LAYOUT = { bankCount: 20, banks: [] };

let cur = { bank: 0, page: 0, btn: 0 };
let MAP = null;

function wrap(n, max) {
  let r = n % max;
  if (r < 0) r += max;
  return r;
}

function setMsg(text, ok = true) {
  const el = $("msg");
  el.textContent = text || "";
  el.className = "msg " + (ok ? "ok" : "bad");
}

async function apiGet(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

async function apiPost(url, obj) {
  const r = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(obj),
  });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

function curBankObj() {
  return (LAYOUT.banks || [])[cur.bank];
}

function curPageCount() {
  const b = curBankObj();
  return b ? (b.pageCount || 1) : 1;
}

function renderHeader() {
  $("curBank").textContent = cur.bank;
  $("curPage").textContent = cur.page;

  const b = curBankObj();
  $("curBankName").textContent = (b && b.name) ? b.name : "Bank";
  $("curPageName").textContent = (b && b.pages && b.pages[cur.page]) ? b.pages[cur.page] : "Page";

  $("bankName").value = (b && b.name) ? b.name : "";
  $("pageName").value = (b && b.pages && b.pages[cur.page]) ? b.pages[cur.page] : "";
}

function makeGrid() {
  const g = $("btnGrid");
  g.innerHTML = "";

  const count = META.buttons || 8;
  for (let i = 0; i < count; i++) {
    const b = document.createElement("button");
    b.className = "pad";
    b.textContent = String(i + 1);
    b.onclick = async () => {
      try {
        cur.btn = i;
        highlightGrid();
        await loadButton();
      } catch (e) {
        setMsg("Load button failed: " + e.message, false);
      }
    };
    b.dataset.idx = String(i);
    g.appendChild(b);
  }
  highlightGrid();
}

function highlightGrid() {
  const pads = Array.from($("btnGrid").querySelectorAll(".pad"));
  pads.forEach((p) => {
    const i = Number(p.dataset.idx);
    p.classList.toggle("active", i === cur.btn);
  });
}

// ---- Action row UI helpers ----
function getCcBehavior() {
  return Number(($("ccBehavior").value || "0"));
}

function setInputVisible(inp, visible) {
  inp.style.display = visible ? "" : "none";
}

function setHints(row, hints) {
  // ใช้ title/placeholder เพื่อบอกความหมาย (ไม่ต้องแก้ CSS/HTML เพิ่ม)
  const ch = row._ch;
  const a  = row._a;
  const b  = row._b;
  const c  = row._c;

  ch.title = hints.chTitle || "";
  a.title  = hints.aTitle  || "";
  b.title  = hints.bTitle  || "";
  c.title  = hints.cTitle  || "";

  ch.placeholder = hints.chPh || "";
  a.placeholder  = hints.aPh  || "";
  b.placeholder  = hints.bPh  || "";
  c.placeholder  = hints.cPh  || "";
}

function applyRowVisibility(row) {
  const type = row._type.value;
  const ccBeh = getCcBehavior();

  // default show
  setInputVisible(row._ch, true);
  setInputVisible(row._a, true);
  setInputVisible(row._b, true);
  setInputVisible(row._c, true);

  // default ranges (safe)
  row._ch.min = 1; row._ch.max = 16;
  row._a.min = 0;  row._a.max = 127;
  row._b.min = 0;  row._b.max = 127;
  row._c.min = 0;  row._c.max = 127;

  if (type === "cc") {
    // CC: a=CC#, b=valA, c=valB (เฉพาะ toggle/momentary)
    setHints(row, {
      chPh: "ch", aPh: "cc", bPh: "valA", cPh: "valB",
      chTitle: "MIDI Channel 1..16",
      aTitle: "CC number 0..127",
      bTitle: "Value A 0..127",
      cTitle: "Value B 0..127 (Toggle/Momentary)"
    });

    if (ccBeh === 0) {
      // Normal: ไม่ใช้ valB
      setInputVisible(row._c, false);
    } else {
      setInputVisible(row._c, true);
    }
  } else if (type === "pc") {
    // PC: ch, a=PC
    setHints(row, {
      chPh: "ch", aPh: "pc",
      chTitle: "MIDI Channel 1..16",
      aTitle: "Program number 0..127"
    });
    row._a.max = 127;
    setInputVisible(row._b, false);
    setInputVisible(row._c, false);
  } else if (type === "note") {
    // NOTE: ch, a=note, b=vel, c=dur*10ms
    setHints(row, {
      chPh: "ch", aPh: "note", bPh: "vel", cPh: "dur(×10ms)",
      chTitle: "MIDI Channel 1..16",
      aTitle: "Note number 0..127",
      bTitle: "Velocity 0..127",
      cTitle: "Duration unit = 10ms (0 => 50ms default in firmware)"
    });
    row._c.max = 255;
  } else if (type === "delay") {
    // DELAY: a=ms_hi, b=ms_lo (ch ignored)
    setHints(row, {
      aPh: "ms_hi", bPh: "ms_lo",
      aTitle: "Delay ms high byte (ms = (a<<8)|b)",
      bTitle: "Delay ms low byte (ms = (a<<8)|b)"
    });
    setInputVisible(row._ch, false);
    setInputVisible(row._c, false);
    row._a.max = 255;
    row._b.max = 255;
  } else if (type === "bank_pc") {
    // BANK_PC: ch, a=PC, b=LSB, c=MSB
    setHints(row, {
      chPh: "ch", aPh: "pc", bPh: "lsb", cPh: "msb",
      chTitle: "MIDI Channel 1..16",
      aTitle: "Program 0..127",
      bTitle: "Bank LSB (CC32) 0..127",
      cTitle: "Bank MSB (CC0) 0..127"
    });
  } else {
    // unknown -> show minimal
    setHints(row, {});
  }
}

function mkActionRow(action, onRemove) {
  const row = document.createElement("div");
  row.className = "action";

  const type = document.createElement("select");
  ["cc", "pc", "note", "delay", "bank_pc"].forEach((t) => {
    const o = document.createElement("option");
    o.value = t;
    o.textContent = t;
    type.appendChild(o);
  });
  type.value = action.type || "cc";

  const ch = document.createElement("input");
  ch.type = "number";
  ch.min = 1;
  ch.max = 16;
  ch.value = (action.ch ?? 1);

  const a = document.createElement("input");
  a.type = "number";
  a.min = 0;
  a.max = 127;
  a.value = (action.a ?? 0);

  const b = document.createElement("input");
  b.type = "number";
  b.min = 0;
  b.max = 127;
  b.value = (action.b ?? 0);

  const c = document.createElement("input");
  c.type = "number";
  c.min = 0;
  c.max = 127;
  c.value = (action.c ?? 0);

  const rm = document.createElement("button");
  rm.className = "x";
  rm.textContent = "×";
  rm.onclick = () => onRemove(row);

  row.append(type, ch, a, b, c, rm);

  row._type = type;
  row._ch = ch;
  row._a = a;
  row._b = b;
  row._c = c;

  row._get = () => ({
    type: type.value,
    ch: Number(ch.value || 1),
    a: Number(a.value || 0),
    b: Number(b.value || 0),
    c: Number(c.value || 0),
  });

  const refresh = () => applyRowVisibility(row);
  type.onchange = refresh;

  // initial
  refresh();

  return row;
}

function renderActions(listEl, actions) {
  listEl.innerHTML = "";
  (actions || []).forEach((act) => {
    const row = mkActionRow(act, (r) => r.remove());
    listEl.appendChild(row);
  });
}

function collectActions(listEl) {
  const rows = Array.from(listEl.querySelectorAll(".action"));
  return rows.map((r) => r._get());
}

function applyUIFromMap(m) {
  $("pressMode").value = String(m.pressMode ?? 0);
  $("ccBehavior").value = String(m.ccBehavior ?? 0);

  renderActions($("shortList"), m.short || []);
  renderActions($("longList"), m.long || []);

  // หลังเปลี่ยน ccBehavior ให้ refresh visibility ทุก row
  refreshAllRows();
}

function readUIToMap() {
  return {
    pressMode: Number($("pressMode").value),
    ccBehavior: Number($("ccBehavior").value),
    short: collectActions($("shortList")),
    long: collectActions($("longList")),
  };
}

function refreshAllRows() {
  const rows = Array.from(document.querySelectorAll(".action"));
  rows.forEach((r) => {
    if (r && typeof r._get === "function") {
      applyRowVisibility(r);
    }
  });
}

async function loadMeta() {
  try {
    META = await apiGet("/api/meta");
  } catch (_) {
    // silent fallback
  }
}

async function loadLayout() {
  LAYOUT = await apiGet("/api/layout");

  // normalize
  const bc = Number(LAYOUT.bankCount || 1);
  LAYOUT.bankCount = bc;

  const rawBanks = (LAYOUT.banks || []).slice(0, bc);
  LAYOUT.banks = rawBanks.map((b, idx) => {
    const pc = Number((b && b.pageCount) ? b.pageCount : 1);
    const pages0 = (b && b.pages) ? b.pages : [];
    const pages = pages0.slice(0, pc).map((s) => String(s || "").slice(0, 15));
    while (pages.length < pc) pages.push("Page " + (pages.length + 1));

    return {
      index: idx,
      name: String((b && b.name) ? b.name : ("Bank " + (idx + 1))).slice(0, 15),
      pageCount: Math.max(1, Math.min(4, pc)),
      pages,
    };
  });

  // ถ้าข้อมูล banks สั้นเกิน bc ให้เติม
  while (LAYOUT.banks.length < bc) {
    const idx = LAYOUT.banks.length;
    LAYOUT.banks.push({
      index: idx,
      name: ("Bank " + (idx + 1)).slice(0, 15),
      pageCount: 1,
      pages: ["Page 1"],
    });
  }

  // clamp cur
  cur.bank = wrap(cur.bank, LAYOUT.bankCount);
  cur.page = wrap(cur.page, curPageCount());
}

async function saveLayout() {
  const payload = {
    bankCount: LAYOUT.bankCount,
    banks: LAYOUT.banks.map((b, idx) => ({
      index: idx,
      name: String(b.name || "").slice(0, 15),
      pageCount: b.pageCount,
      pages: (b.pages || []).slice(0, b.pageCount).map((s) => String(s || "").slice(0, 15)),
    })),
  };
  await apiPost("/api/layout", payload);
}

async function loadButton() {
  renderHeader();
  setMsg("Loading…");
  const url = `/api/button?bank=${cur.bank}&page=${cur.page}&btn=${cur.btn}`;
  MAP = await apiGet(url);
  applyUIFromMap(MAP);

  const b = curBankObj();
  const bn = (b && b.name) ? b.name : "Bank";
  const pn = (b && b.pages && b.pages[cur.page]) ? b.pages[cur.page] : "Page";
  setMsg(`Loaded: ${bn} / ${pn} · Btn ${cur.btn + 1}`);
}

async function saveButton() {
  const url = `/api/button?bank=${cur.bank}&page=${cur.page}&btn=${cur.btn}`;
  const payload = readUIToMap();
  await apiPost(url, payload);
  setMsg("Saved ✅");
}

async function pollLive() {
  try {
    const st = await apiGet("/api/state");
    $("liveBank").textContent = st.bank;
    $("livePage").textContent = st.page;
  } catch (_) {}
  setTimeout(pollLive, 500);
}

function setupUI() {
  $("bankMinus").onclick = async () => {
    try {
      cur.bank = wrap(cur.bank - 1, LAYOUT.bankCount);
      cur.page = wrap(cur.page, curPageCount());
      await loadButton();
    } catch (e) {
      setMsg("Bank- failed: " + e.message, false);
    }
  };

  $("bankPlus").onclick = async () => {
    try {
      cur.bank = wrap(cur.bank + 1, LAYOUT.bankCount);
      cur.page = wrap(cur.page, curPageCount());
      await loadButton();
    } catch (e) {
      setMsg("Bank+ failed: " + e.message, false);
    }
  };

  $("pageMinus").onclick = async () => {
    try {
      cur.page = wrap(cur.page - 1, curPageCount());
      await loadButton();
    } catch (e) {
      setMsg("Page- failed: " + e.message, false);
    }
  };

  $("pagePlus").onclick = async () => {
    try {
      cur.page = wrap(cur.page + 1, curPageCount());
      await loadButton();
    } catch (e) {
      setMsg("Page+ failed: " + e.message, false);
    }
  };

  $("btnAddBank").onclick = async () => {
    try {
      if (LAYOUT.bankCount >= (META.maxBanks || 20)) throw new Error("Max banks reached");
      const idx = LAYOUT.bankCount;
      LAYOUT.bankCount += 1;
      LAYOUT.banks.push({
        index: idx,
        name: `Bank ${idx + 1}`,
        pageCount: 1,
        pages: ["Page 1"],
      });
      await saveLayout();
      await loadLayout();
      cur.bank = idx;
      cur.page = 0;
      await loadButton();
      setMsg("Added Bank ✅");
    } catch (e) {
      setMsg("Add bank failed: " + e.message, false);
    }
  };

  $("btnDelBank").onclick = async () => {
    try {
      if (LAYOUT.bankCount <= 1) throw new Error("Need at least 1 bank");
      LAYOUT.bankCount -= 1;
      LAYOUT.banks = LAYOUT.banks.slice(0, LAYOUT.bankCount);
      await saveLayout();
      await loadLayout();
      cur.bank = wrap(cur.bank, LAYOUT.bankCount);
      cur.page = wrap(cur.page, curPageCount());
      await loadButton();
      setMsg("Deleted Bank ✅");
    } catch (e) {
      setMsg("Del bank failed: " + e.message, false);
    }
  };

  $("btnAddPage").onclick = async () => {
    try {
      const b = curBankObj();
      if (!b) throw new Error("No bank");
      if (b.pageCount >= (META.maxPages || 4)) throw new Error("Max pages reached");
      b.pageCount += 1;
      b.pages = b.pages || [];
      b.pages.push(`Page ${b.pageCount}`);
      await saveLayout();
      await loadLayout();
      cur.page = b.pageCount - 1;
      await loadButton();
      setMsg("Added Page ✅");
    } catch (e) {
      setMsg("Add page failed: " + e.message, false);
    }
  };

  $("btnDelPage").onclick = async () => {
    try {
      const b = curBankObj();
      if (!b) throw new Error("No bank");
      if (b.pageCount <= 1) throw new Error("Need at least 1 page");
      b.pageCount -= 1;
      b.pages = (b.pages || []).slice(0, b.pageCount);
      await saveLayout();
      await loadLayout();
      cur.page = wrap(cur.page, curPageCount());
      await loadButton();
      setMsg("Deleted Page ✅");
    } catch (e) {
      setMsg("Del page failed: " + e.message, false);
    }
  };

  $("btnSaveNames").onclick = async () => {
    try {
      const b = curBankObj();
      if (!b) throw new Error("No bank");
      b.name = String($("bankName").value || "").slice(0, 15);
      b.pages[cur.page] = String($("pageName").value || "").slice(0, 15);
      await saveLayout();
      await loadLayout();
      renderHeader();
      setMsg("Saved names ✅");
    } catch (e) {
      setMsg("Save names failed: " + e.message, false);
    }
  };

  $("addShort").onclick = () => {
    const row = mkActionRow({ type: "cc", ch: 1, a: 0, b: 127, c: 0 }, (r) => r.remove());
    $("shortList").appendChild(row);
    refreshAllRows();
  };

  $("addLong").onclick = () => {
    const row = mkActionRow({ type: "cc", ch: 1, a: 0, b: 127, c: 0 }, (r) => r.remove());
    $("longList").appendChild(row);
    refreshAllRows();
  };

  $("btnSave").onclick = async () => {
    try {
      await saveButton();
    } catch (e) {
      setMsg("Save failed: " + e.message, false);
    }
  };

  $("btnReload").onclick = async () => {
    try {
      await loadButton();
    } catch (e) {
      setMsg("Reload failed: " + e.message, false);
    }
  };

  $("btnSyncFromLive").onclick = async () => {
    try {
      const st = await apiGet("/api/state");
      cur.bank = wrap(st.bank, LAYOUT.bankCount);
      cur.page = wrap(st.page, curPageCount());
      cur.btn = 0;
      highlightGrid();
      await loadButton();
      setMsg("Synced from live ✅");
    } catch (e) {
      setMsg("Sync failed: " + e.message, false);
    }
  };

  $("pressMode").onchange = () => setMsg("Press mode changed (remember to Save)");
  $("ccBehavior").onchange = () => {
    setMsg("CC behavior changed (remember to Save)");
    refreshAllRows();
  };
}

window.addEventListener("load", async () => {
  try {
    await loadMeta();
    await loadLayout();
    setupUI();
    makeGrid();

    renderHeader();
    await loadButton();
    pollLive();
  } catch (e) {
    setMsg("Init failed: " + e.message, false);
  }
});

===== END FILE: spiffs\app.js =====

===== FILE: spiffs\index.html =====
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Footswitch MIDI</title>
  <link rel="stylesheet" href="/style.css"/>
</head>
<body>
  <div class="wrap">
    <header class="top">
      <div class="brand">
        <div class="dot"></div>
        <div>
          <div class="title">Footswitch MIDI</div>
          <div class="sub">Captive portal setup</div>
        </div>
      </div>

      <div class="live">
        <div class="pill">Live: Bank <span id="liveBank">0</span> · Page <span id="livePage">0</span></div>
        <button class="btn ghost" id="btnSyncFromLive">Sync editor ← live</button>
      </div>
    </header>

    <section class="card">
      <div class="row space">
        <div class="group">
          <div class="label">Bank</div>
          <div class="stepper">
            <button class="btn" id="bankMinus">−</button>
            <div class="value">
              <div class="vnum">#<span id="curBank">0</span></div>
              <div class="vname" id="curBankName">Bank</div>
            </div>
            <button class="btn" id="bankPlus">+</button>
          </div>
          <div class="row">
            <button class="btn ghost" id="btnAddBank">+ Bank</button>
            <button class="btn ghost danger" id="btnDelBank">− Bank</button>
          </div>
        </div>

        <div class="group">
          <div class="label">Page</div>
          <div class="stepper">
            <button class="btn" id="pageMinus">−</button>
            <div class="value">
              <div class="vnum">#<span id="curPage">0</span></div>
              <div class="vname" id="curPageName">Page</div>
            </div>
            <button class="btn" id="pagePlus">+</button>
          </div>
          <div class="row">
            <button class="btn ghost" id="btnAddPage">+ Page</button>
            <button class="btn ghost danger" id="btnDelPage">− Page</button>
          </div>
        </div>

        <div class="group wide">
          <div class="label">Rename (Bank / Page)</div>
          <div class="row">
            <input class="inp" id="bankName" placeholder="Bank name (max 15 chars)"/>
            <input class="inp" id="pageName" placeholder="Page name (max 15 chars)"/>
            <button class="btn" id="btnSaveNames">Save names</button>
          </div>
          <div class="hint">
            Hardware combo: (5&6)=Bank−, (7&8)=Bank+, (6&7)=Page+ 🔁
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="row space">
        <div class="group">
          <div class="label">Press mode</div>
          <select id="pressMode" class="sel">
            <option value="0">Immediate (press = run now)</option>
            <option value="1">Short + Long (500ms)</option>
          </select>
        </div>

        <div class="group">
          <div class="label">CC behavior</div>
          <select id="ccBehavior" class="sel">
            <option value="0">Normal (valA=b)</option>
            <option value="1">Toggle (valA=b, valB=c)</option>
            <option value="2">Momentary (Down=b, Up=c)</option>
          </select>
        </div>

        <div class="group right">
          <div class="label">Select Button</div>
          <div class="grid" id="btnGrid"></div>
        </div>
      </div>

      <div class="row space" style="margin-top:10px;">
        <div class="small">
          CC fields: a=CC#, b=valA, c=valB (Toggle/Momentary) • Note: c=dur*10ms • Delay: ms=(a<<8|b)
        </div>
        <div class="row">
          <button class="btn primary" id="btnSave">Save this button</button>
          <button class="btn ghost" id="btnReload">Reload</button>
        </div>
      </div>

      <div class="split">
        <div>
          <div class="h3">Short actions</div>
          <div id="shortList" class="list"></div>
          <button class="btn ghost" id="addShort">+ Add short action</button>
        </div>

        <div>
          <div class="h3">Long actions</div>
          <div id="longList" class="list"></div>
          <button class="btn ghost" id="addLong">+ Add long action</button>
        </div>
      </div>

      <div id="msg" class="msg"></div>
    </section>

    <footer class="foot">
      <div class="small">
        Tip: bank_pc → a=PC, b=LSB, c=MSB ✅
      </div>
    </footer>
  </div>

  <script src="/app.js"></script>
</body>
</html>

===== END FILE: spiffs\index.html =====

===== FILE: spiffs\style.css =====
:root{
  --bg0:#0b0c10;
  --bg1:#0f1320;
  --card: rgba(255,255,255,.06);
  --line: rgba(255,255,255,.10);
  --text: rgba(255,255,255,.90);
  --muted: rgba(255,255,255,.60);
  --ok:#4ade80;
  --bad:#fb7185;
  --shadow: 0 20px 50px rgba(0,0,0,.40);
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  color:var(--text);
  background: radial-gradient(1200px 700px at 20% 10%, #1a2440 0%, transparent 60%),
              radial-gradient(900px 500px at 80% 30%, #2a1b3f 0%, transparent 55%),
              linear-gradient(180deg, var(--bg0), var(--bg1));
}

.wrap{ max-width: 1020px; margin: 0 auto; padding: 18px; }

.top{
  display:flex; align-items:center; justify-content:space-between;
  gap:12px; padding: 10px 2px 18px;
}

.brand{ display:flex; align-items:center; gap:12px; }
.dot{
  width:12px; height:12px; border-radius:50%;
  background: linear-gradient(180deg,#a78bfa,#60a5fa);
  box-shadow: 0 0 0 6px rgba(167,139,250,.12);
}
.title{ font-weight: 650; letter-spacing:.2px; font-size:18px; }
.sub{ color:var(--muted); font-size:12px; margin-top:2px; }

.live{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
.pill{
  padding:10px 12px;
  background: rgba(255,255,255,.05);
  border: 1px solid var(--line);
  border-radius: 999px;
  color: var(--muted);
}

.card{
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 18px;
  padding: 14px;
  box-shadow: var(--shadow);
  backdrop-filter: blur(10px);
  margin: 12px 0;
}

.row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
.space{ justify-content:space-between; }

.group{ display:flex; flex-direction:column; gap:8px; min-width: 220px; }
.group.wide{ flex: 1 1 420px; }
.group.right{ margin-left:auto; display:flex; flex-direction:column; gap:10px; }

.label{ font-size:12px; color: var(--muted); }
.value{
  min-width: 160px;
  padding: 10px 12px;
  border-radius: 12px;
  background: rgba(255,255,255,.04);
  border: 1px solid var(--line);
}
.vnum{ font-size: 12px; color: var(--muted); }
.vname{ font-size: 14px; font-weight: 650; margin-top: 2px; }

.stepper{ display:flex; gap:10px; align-items:center; }

.sel{
  padding: 12px 12px;
  border-radius: 12px;
  border: 1px solid var(--line);
  background: rgba(0,0,0,.20);
  color: var(--text);
  outline: none;
}

.inp{
  flex: 1 1 240px;
  padding: 12px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  color: var(--text);
  outline:none;
}

.btn{
  padding: 11px 12px;
  border-radius: 12px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,.06);
  color: var(--text);
  cursor:pointer;
  transition: transform .06s ease, background .15s ease, border-color .15s ease;
}
.btn:hover{ background: rgba(255,255,255,.10); }
.btn:active{ transform: translateY(1px); }

.btn.primary{
  border-color: rgba(96,165,250,.35);
  background: rgba(96,165,250,.16);
}
.btn.ghost{
  background: rgba(0,0,0,.10);
}
.btn.danger{
  border-color: rgba(251,113,133,.35);
  background: rgba(251,113,133,.12);
}

.grid{
  display:grid;
  grid-template-columns: repeat(8, minmax(0,1fr));
  gap:8px;
  min-width: 360px;
}
.pad{
  padding: 14px 0;
  border-radius: 14px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,.06);
  color: var(--text);
  cursor:pointer;
  transition: background .15s ease, transform .06s ease, border-color .15s ease;
}
.pad:hover{ background: rgba(255,255,255,.10); }
.pad:active{ transform: translateY(1px); }
.pad.active{
  border-color: rgba(167,139,250,.55);
  background: rgba(167,139,250,.18);
}

.hint{
  margin-top:10px;
  color: var(--muted);
  font-size: 12px;
}

.split{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:14px;
  margin-top: 10px;
}
@media (max-width: 900px){
  .split{ grid-template-columns: 1fr; }
  .grid{ grid-template-columns: repeat(4, minmax(0,1fr)); min-width: 0; }
  .group{ min-width: 160px; }
}

.h3{ font-weight:650; margin: 8px 0 10px; }

.list{ display:flex; flex-direction:column; gap:8px; }

.action{
  display:grid;
  grid-template-columns: 120px 70px 70px 70px 70px 44px;
  gap:8px;
  align-items:center;
  padding:10px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.15);
}
.action select, .action input{
  padding: 10px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  color: var(--text);
  outline:none;
}
.action .x{
  width: 44px; height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: var(--text);
  cursor:pointer;
}
.action .x:hover{ background: rgba(255,255,255,.10); }

.msg{
  margin-top:12px;
  font-size: 13px;
  color: var(--muted);
}
.msg.ok{ color: var(--ok); }
.msg.bad{ color: var(--bad); }

.foot{ padding: 4px 2px 20px; }
.small{ color: var(--muted); font-size: 12px; }

===== END FILE: spiffs\style.css =====


